// Code generated by ndn tlv codegen DO NOT EDIT.
package gen_map

import (
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type StringMapEncoder struct {
	Length uint

	Params_valencoder map[string]*struct {
	}
}

type StringMapParsingContext struct {
}

// Initializes the StringMapEncoder with the provided StringMap, calculating the total encoded length of all key-value parameters using TLV encoding rules.
func (encoder *StringMapEncoder) Init(value *StringMap) {
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the StringMapParsingContext, preparing it for parsing operations with default settings.
func (context *StringMapParsingContext) Init() {

}

// Encodes a StringMap's key-value pairs into a TLV-encoded byte buffer using type identifiers 0x85 for keys and 0x87 for values.
func (encoder *StringMapEncoder) EncodeInto(value *StringMap, buf []byte) {

	pos := uint(0)

	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the provided StringMap into a byte slice using the encoder's length and returns it as a single-component Wire structure.
func (encoder *StringMapEncoder) Encode(value *StringMap) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded StringMap from the provided wire format reader, extracting parameters (type 133) as key-value pairs (string keys and byte slices) and handling unrecognized or critical fields according to the ignoreCritical flag.
func (context *StringMapParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*StringMap, error) {

	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &StringMap{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the StringMap value into a Wire format using a StringMapEncoder.
func (value *StringMap) Encode() enc.Wire {
	encoder := StringMapEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte slice formed by encoding and joining the elements of the StringMap.
func (value *StringMap) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a StringMap from a wire-encoded format using the provided reader, with an option to ignore critical unrecognized elements.
func ParseStringMap(reader enc.WireView, ignoreCritical bool) (*StringMap, error) {
	context := StringMapParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type InnerEncoder struct {
	Length uint
}

type InnerParsingContext struct {
}

// Initializes the encoder's length by calculating the combined size of a fixed field and the variable-length encoded value of the `Num` field from the provided `Inner` struct.
func (encoder *InnerEncoder) Init(value *Inner) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Num).EncodingLength())
	encoder.Length = l

}

// Initializes the InnerParsingContext, preparing it for parsing operations.
func (context *InnerParsingContext) Init() {

}

// Encodes the given Inner struct into a binary format in the provided buffer, writing a type tag (1) followed by a length-prefixed encoding of the Num field as a natural number.
func (encoder *InnerEncoder) EncodeInto(value *Inner, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(1)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Num).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes the provided Inner value into a byte slice of the pre-determined length specified by the encoder, returning it as a single-element enc.Wire structure containing the encoded data.
func (encoder *InnerEncoder) Encode(value *Inner) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded data into an Inner structure, extracting a required uint64 "Num" field (type 1) and handling critical/non-critical fields according to the ignoreCritical flag.
func (context *InnerParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Inner, error) {

	var handled_Num bool = false

	progress := -1
	_ = progress

	value := &Inner{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Num = true
					value.Num = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Num = uint64(value.Num<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Num && err == nil {
		err = enc.ErrSkipRequired{Name: "Num", TypeNum: 1}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the Inner value into its wire format representation using an InnerEncoder.
func (value *Inner) Encode() enc.Wire {
	encoder := InnerEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte slice representing the TLV-encoded form of the Inner value.
func (value *Inner) Bytes() []byte {
	return value.Encode().Join()
}

// Parses encoded data into an Inner structure using the provided WireView, with an option to ignore critical elements if specified.
func ParseInner(reader enc.WireView, ignoreCritical bool) (*Inner, error) {
	context := InnerParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type IntStructMapEncoder struct {
	Length uint

	Params_valencoder map[uint64]*struct {
		Params_v_encoder InnerEncoder
	}
}

type IntStructMapParsingContext struct {
	Params_v_context InnerParsingContext
}

// Initializes an IntStructMapEncoder with the provided IntStructMap, setting up nested encoders for each map entry and calculating the total encoded length including keys and nested values.
func (encoder *IntStructMapEncoder) Init(value *IntStructMap) {
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[uint64]*struct {
			Params_v_encoder InnerEncoder
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
				Params_v_encoder InnerEncoder
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v *Inner
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Params_v != nil {
					encoder.Params_v_encoder.Init(value.Params_v)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k uint64
				Params_v *Inner
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(1 + enc.Nat(value.Params_k).EncodingLength())
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Params_v_encoder.Length).EncodingLength())
					l += encoder.Params_v_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the internal Params_v_context field by invoking its Init method to prepare for parsing.
func (context *IntStructMapParsingContext) Init() {
	context.Params_v_context.Init()
}

// Encodes a map of uint64 keys and *Inner values into a binary buffer using type-length-value encoding with specific tag bytes (0x85 for keys, 0x87 for values) and length prefixes.
func (encoder *IntStructMapEncoder) EncodeInto(value *IntStructMap, buf []byte) {

	pos := uint(0)

	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k uint64
				Params_v *Inner
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1

				buf[pos] = byte(enc.Nat(value.Params_k).EncodeInto(buf[pos+1:]))
				pos += uint(1 + buf[pos])
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(encoder.Params_v_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Params_v_encoder.Length > 0 {
						encoder.Params_v_encoder.EncodeInto(value.Params_v, buf[pos:])
						pos += encoder.Params_v_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes an IntStructMap into a pre-allocated wire buffer, returning a structured byte slice suitable for NDN data transmission.
func (encoder *IntStructMapEncoder) Encode(value *IntStructMap) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded data into an IntStructMap, handling map entries with uint64 keys and Inner values (type 133/135), while enforcing critical field rules based on the ignoreCritical flag.
func (context *IntStructMapParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*IntStructMap, error) {

	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &IntStructMap{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[uint64]*Inner)
					}
					{
						pseudoValue := struct {
							Params_k uint64
							Params_v *Inner
						}{}
						{
							value := &pseudoValue
							value.Params_k = uint64(0)
							{
								for i := 0; i < int(l); i++ {
									x := byte(0)
									x, err = reader.ReadByte()
									if err != nil {
										if err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										break
									}
									value.Params_k = uint64(value.Params_k<<8) | uint64(x)
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v, err = context.Params_v_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the IntStructMap into a wire-encoded format for transmission or storage.
func (value *IntStructMap) Encode() enc.Wire {
	encoder := IntStructMapEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte representation of the IntStructMap by concatenating its encoded components.
func (value *IntStructMap) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded Integer Struct Map into a Go struct, optionally ignoring critical fields.
func ParseIntStructMap(reader enc.WireView, ignoreCritical bool) (*IntStructMap, error) {
	context := IntStructMapParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
