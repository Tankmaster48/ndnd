// Code generated by ndn tlv codegen DO NOT EDIT.
package gen_basic

import (
	"encoding/binary"
	"io"
	"strings"

	"time"

	enc "github.com/named-data/ndnd/std/encoding"
)

type FakeMetaInfoEncoder struct {
	Length uint
}

type FakeMetaInfoParsingContext struct {
}

// Calculates the total length required to encode the FakeMetaInfo fields (Number, Time, and optional Binary) in a TLV format, including type markers and variable-length encodings, and sets the result on the encoder.
func (encoder *FakeMetaInfoEncoder) Init(value *FakeMetaInfo) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Number).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(uint64(value.Time/time.Millisecond)).EncodingLength())
	if value.Binary != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Binary)).EncodingLength())
		l += uint(len(value.Binary))
	}
	encoder.Length = l

}

// Initializes the fake metadata parsing context to a default state, preparing it for test scenarios involving metadata parsing operations.
func (context *FakeMetaInfoParsingContext) Init() {

}

// Encodes a FakeMetaInfo struct into a TLV (Type-Length-Value) binary format in the provided buffer, including the Number (type 24), Time in milliseconds (type 25), and optional Binary data (type 26) fields.
func (encoder *FakeMetaInfoEncoder) EncodeInto(value *FakeMetaInfo, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(24)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Number).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(25)
	pos += 1

	buf[pos] = byte(enc.Nat(uint64(value.Time / time.Millisecond)).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Binary != nil {
		buf[pos] = byte(26)
		pos += 1
		pos += uint(enc.TLNum(len(value.Binary)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Binary)
		pos += uint(len(value.Binary))
	}
}

// Encodes a `FakeMetaInfo` object into a byte slice using the encoder's `EncodeInto` method and wraps the result in an `enc.Wire` structure for transmission or storage.
func (encoder *FakeMetaInfoEncoder) Encode(value *FakeMetaInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded MetaInfo data into a FakeMetaInfo struct, requiring Number and Time fields, with optional Binary data and configurable handling of critical fields.
func (context *FakeMetaInfoParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FakeMetaInfo, error) {

	var handled_Number bool = false
	var handled_Time bool = false
	var handled_Binary bool = false

	progress := -1
	_ = progress

	value := &FakeMetaInfo{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 24:
				if true {
					handled = true
					handled_Number = true
					value.Number = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Number = uint64(value.Number<<8) | uint64(x)
						}
					}
				}
			case 25:
				if true {
					handled = true
					handled_Time = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						value.Time = time.Duration(timeInt) * time.Millisecond
					}
				}
			case 26:
				if true {
					handled = true
					handled_Binary = true
					value.Binary = make([]byte, l)
					_, err = reader.ReadFull(value.Binary)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Number && err == nil {
		err = enc.ErrSkipRequired{Name: "Number", TypeNum: 24}
	}
	if !handled_Time && err == nil {
		err = enc.ErrSkipRequired{Name: "Time", TypeNum: 25}
	}
	if !handled_Binary && err == nil {
		value.Binary = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FakeMetaInfo into its wire format using a FakeMetaInfoEncoder for transmission or storage.
func (value *FakeMetaInfo) Encode() enc.Wire {
	encoder := FakeMetaInfoEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the concatenated byte slice of the encoded metadata information.
func (value *FakeMetaInfo) Bytes() []byte {
	return value.Encode().Join()
}

// Parses encoded metadata into a FakeMetaInfo instance from a WireView, with an option to ignore critical fields during parsing.
func ParseFakeMetaInfo(reader enc.WireView, ignoreCritical bool) (*FakeMetaInfo, error) {
	context := FakeMetaInfoParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type OptFieldEncoder struct {
	Length uint
}

type OptFieldParsingContext struct {
}

// Calculates the total encoded length for an optional field encoder by summing the TLV-encoded sizes of present fields (Number, Time, Binary, Bool) in the provided OptField.
func (encoder *OptFieldEncoder) Init(value *OptField) {

	l := uint(0)
	if optval, ok := value.Number.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Time.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.Binary != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Binary)).EncodingLength())
		l += uint(len(value.Binary))
	}
	if value.Bool {
		l += 1
		l += 1
	}
	encoder.Length = l

}

// Initializes the optional field parsing context, intended to be overridden by subclasses for custom setup.
func (context *OptFieldParsingContext) Init() {

}

// Encodes an optional field (OptField) into a binary buffer using a TLV (Type-Length-Value) format, handling numeric, time, binary, and boolean values with distinct type codes (24, 25, 26, 48) and variable-length encoding.
func (encoder *OptFieldEncoder) EncodeInto(value *OptField, buf []byte) {

	pos := uint(0)

	if optval, ok := value.Number.Get(); ok {
		buf[pos] = byte(24)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Time.Get(); ok {
		buf[pos] = byte(25)
		pos += 1

		buf[pos] = byte(enc.Nat(uint64(optval / time.Millisecond)).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Binary != nil {
		buf[pos] = byte(26)
		pos += 1
		pos += uint(enc.TLNum(len(value.Binary)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Binary)
		pos += uint(len(value.Binary))
	}
	if value.Bool {
		buf[pos] = byte(48)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

// Encodes the provided optional field into its wire format byte slice using the encoder's specified length and returns it wrapped in a Wire structure.
func (encoder *OptFieldEncoder) Encode(value *OptField) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a wire-encoded TLV structure into an OptField, handling Number (type 24), Time (type 25), Binary (type 26), and Bool (type 48) fields while respecting criticality and defaulting unset fields.
func (context *OptFieldParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*OptField, error) {

	var handled_Number bool = false
	var handled_Time bool = false
	var handled_Binary bool = false
	var handled_Bool bool = false

	progress := -1
	_ = progress

	value := &OptField{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 24:
				if true {
					handled = true
					handled_Number = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Number.Set(optval)
					}
				}
			case 25:
				if true {
					handled = true
					handled_Time = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						optval := time.Duration(timeInt) * time.Millisecond
						value.Time.Set(optval)
					}
				}
			case 26:
				if true {
					handled = true
					handled_Binary = true
					value.Binary = make([]byte, l)
					_, err = reader.ReadFull(value.Binary)
				}
			case 48:
				if true {
					handled = true
					handled_Bool = true
					value.Bool = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Number && err == nil {
		value.Number.Unset()
	}
	if !handled_Time && err == nil {
		value.Time.Unset()
	}
	if !handled_Binary && err == nil {
		value.Binary = nil
	}
	if !handled_Bool && err == nil {
		value.Bool = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the OptField value into a wire-format representation using an OptFieldEncoder for serialization.
func (value *OptField) Encode() enc.Wire {
	encoder := OptFieldEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the optional field by encoding its value and concatenating the resulting byte slices.
func (value *OptField) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a TLV-encoded optional field from the provided wire format reader, using a parsing context and optionally ignoring critical fields if specified.
func ParseOptField(reader enc.WireView, ignoreCritical bool) (*OptField, error) {
	context := OptFieldParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type WireNameFieldEncoder struct {
	Length uint

	Wire_length uint
	Name_length uint
}

type WireNameFieldParsingContext struct {
}

// Initializes the WireNameFieldEncoder by calculating the total encoded length of the provided WireNameField, summing the TLV-encoded sizes of Wire (raw bytes) and Name (NDN name components).
func (encoder *WireNameFieldEncoder) Init(value *WireNameField) {
	if value.Wire != nil {
		encoder.Wire_length = 0
		for _, c := range value.Wire {
			encoder.Wire_length += uint(len(c))
		}
	}
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Wire != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire_length).EncodingLength())
		l += encoder.Wire_length
	}
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	encoder.Length = l

}

// Initializes the wire name field parsing context, currently serving as a placeholder with no implementation.
func (context *WireNameFieldParsingContext) Init() {

}

// Encodes a WireNameField into a binary buffer using TLV (Type-Length-Value) format, writing encoded Wire and Name components sequentially with type tags 1 and 2 respectively when non-nil.
func (encoder *WireNameFieldEncoder) EncodeInto(value *WireNameField, buf []byte) {

	pos := uint(0)

	if value.Wire != nil {
		buf[pos] = byte(1)
		pos += 1
		pos += uint(enc.TLNum(encoder.Wire_length).EncodeInto(buf[pos:]))
		for _, w := range value.Wire {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}
	if value.Name != nil {
		buf[pos] = byte(2)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

// Encodes the provided WireNameField into a byte slice of the encoder's specified length, returning a single-element Wire slice containing the encoded bytes.
func (encoder *WireNameFieldEncoder) Encode(value *WireNameField) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded name field data into a `WireNameField` struct, extracting either raw wire format bytes or parsed Name components, with optional support for ignoring critical unrecognized fields.
func (context *WireNameFieldParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*WireNameField, error) {

	var handled_Wire bool = false
	var handled_Name bool = false

	progress := -1
	_ = progress

	value := &WireNameField{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Wire = true
					value.Wire, err = reader.ReadWire(int(l))
				}
			case 2:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Wire && err == nil {
		value.Wire = nil
	}
	if !handled_Name && err == nil {
		value.Name = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the WireNameField into a binary wire format for use in NDN protocol messages.
func (value *WireNameField) Encode() enc.Wire {
	encoder := WireNameFieldEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the wire-encoded byte slice representation of the name field by concatenating its encoded components.
func (value *WireNameField) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded name field into a WireNameField structure, optionally ignoring critical TLV elements based on the ignoreCritical flag.
func ParseWireNameField(reader enc.WireView, ignoreCritical bool) (*WireNameField, error) {
	context := WireNameFieldParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type MarkersEncoder struct {
	Length uint

	startMarker     int
	startMarker_pos int
	Wire_length     uint
	argument        int
	Name_length     uint
	endMarker       int
	endMarker_pos   int
}

type MarkersParsingContext struct {
	startMarker int

	argument int

	endMarker int
}

// Initializes the encoder by calculating the total encoded length of the Markers structure, including TLV-encoded Wire and Name fields, and sets start/end markers for subsequent encoding operations.
func (encoder *MarkersEncoder) Init(value *Markers) {

	if value.Wire != nil {
		encoder.Wire_length = 0
		for _, c := range value.Wire {
			encoder.Wire_length += uint(len(c))
		}
	}

	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	encoder.startMarker = int(l)
	if value.Wire != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire_length).EncodingLength())
		l += encoder.Wire_length
	}

	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	encoder.endMarker = int(l)
	encoder.Length = l

}

// Initializes the parsing context, but currently does nothing as the implementation is empty.
func (context *MarkersParsingContext) Init() {

}

// Encodes the provided *Markers value into the given byte buffer using a TLV (Type-Length-Value) format, with separate encoding for Wire and Name fields, marking their start and end positions in the encoder.
func (encoder *MarkersEncoder) EncodeInto(value *Markers, buf []byte) {

	pos := uint(0)

	encoder.startMarker_pos = int(pos)
	if value.Wire != nil {
		buf[pos] = byte(1)
		pos += 1
		pos += uint(enc.TLNum(encoder.Wire_length).EncodeInto(buf[pos:]))
		for _, w := range value.Wire {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}

	if value.Name != nil {
		buf[pos] = byte(2)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	encoder.endMarker_pos = int(pos)
}

// Encodes the provided *Markers value into a byte slice of the encoder's predefined length and returns it as a single-element Wire structure.
func (encoder *MarkersEncoder) Encode(value *Markers) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses binary wire format into a Markers structure, handling specific fields (Wire, Name) and tracking start/end positions in context, with optional critical field tolerance.
func (context *MarkersParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Markers, error) {

	var handled_startMarker bool = false
	var handled_Wire bool = false
	var handled_argument bool = false
	var handled_Name bool = false
	var handled_endMarker bool = false

	progress := -1
	_ = progress

	value := &Markers{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		for handled := false; !handled && progress < 5; progress++ {
			switch typ {
			case 1:
				if progress+1 == 1 {
					handled = true
					handled_Wire = true
					value.Wire, err = reader.ReadWire(int(l))
				}
			case 2:
				if progress+1 == 3 {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					handled_startMarker = true
					context.startMarker = int(startPos)
				case 1 - 1:
					handled_Wire = true
					value.Wire = nil
				case 2 - 1:
					handled_argument = true
					// base - skip
				case 3 - 1:
					handled_Name = true
					value.Name = nil
				case 4 - 1:
					handled_endMarker = true
					context.endMarker = int(startPos)
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_startMarker && err == nil {
		context.startMarker = int(startPos)
	}
	if !handled_Wire && err == nil {
		value.Wire = nil
	}
	if !handled_argument && err == nil {
		// base - skip
	}
	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_endMarker && err == nil {
		context.endMarker = int(startPos)
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

type NoCopyStructEncoder struct {
	Length uint

	wirePlan []uint

	Wire1_length uint

	Wire2_length uint
}

type NoCopyStructParsingContext struct {
}

// Initializes a NoCopyStructEncoder with the provided NoCopyStruct value, calculating the total encoded length and constructing a wire layout plan for efficient encoding of the struct's fields (Wire1, Number, and Wire2) without data copying.
func (encoder *NoCopyStructEncoder) Init(value *NoCopyStruct) {
	if value.Wire1 != nil {
		encoder.Wire1_length = 0
		for _, c := range value.Wire1 {
			encoder.Wire1_length += uint(len(c))
		}
	}

	if value.Wire2 != nil {
		encoder.Wire2_length = 0
		for _, c := range value.Wire2 {
			encoder.Wire2_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.Wire1 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire1_length).EncodingLength())
		l += encoder.Wire1_length
	}
	l += 1
	l += uint(1 + enc.Nat(value.Number).EncodingLength())
	if value.Wire2 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire2_length).EncodingLength())
		l += encoder.Wire2_length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Wire1 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire1_length).EncodingLength())
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Wire1 {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	l += 1
	l += uint(1 + enc.Nat(value.Number).EncodingLength())
	if value.Wire2 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire2_length).EncodingLength())
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Wire2 {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the NoCopyStructParsingContext for parsing operations that avoid data copying.
func (context *NoCopyStructParsingContext) Init() {

}

// Encodes a NoCopyStruct into a wire format by sequentially writing type markers, encoded lengths, and field values (Wire1, Number, Wire2) into a pre-allocated slice of byte buffers, avoiding data copying where possible.
func (encoder *NoCopyStructEncoder) EncodeInto(value *NoCopyStruct, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.Wire1 != nil {
		buf[pos] = byte(1)
		pos += 1
		pos += uint(enc.TLNum(encoder.Wire1_length).EncodeInto(buf[pos:]))
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Wire1 {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
	buf[pos] = byte(2)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Number).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Wire2 != nil {
		buf[pos] = byte(3)
		pos += 1
		pos += uint(enc.TLNum(encoder.Wire2_length).EncodeInto(buf[pos:]))
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Wire2 {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
}

// Encodes a NoCopyStruct into a non-copying wire representation by pre-allocating a byte slice according to the encoder's wirePlan and populating it with the struct's data.
func (encoder *NoCopyStructEncoder) Encode(value *NoCopyStruct) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a binary wire-format structure into a NoCopyStruct, handling required 'Number' (as uint64) and optional 'Wire1/Wire2' fields, with critical-type validation controlled by ignoreCritical.
func (context *NoCopyStructParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NoCopyStruct, error) {

	var handled_Wire1 bool = false
	var handled_Number bool = false
	var handled_Wire2 bool = false

	progress := -1
	_ = progress

	value := &NoCopyStruct{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Wire1 = true
					value.Wire1, err = reader.ReadWire(int(l))
				}
			case 2:
				if true {
					handled = true
					handled_Number = true
					value.Number = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Number = uint64(value.Number<<8) | uint64(x)
						}
					}
				}
			case 3:
				if true {
					handled = true
					handled_Wire2 = true
					value.Wire2, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Wire1 && err == nil {
		value.Wire1 = nil
	}
	if !handled_Number && err == nil {
		err = enc.ErrSkipRequired{Name: "Number", TypeNum: 2}
	}
	if !handled_Wire2 && err == nil {
		value.Wire2 = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the NoCopyStruct value into its wire representation using the NoCopyStructEncoder.
func (value *NoCopyStruct) Encode() enc.Wire {
	encoder := NoCopyStructEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the concatenated byte slice representation of the encoded NoCopyStruct.
func (value *NoCopyStruct) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a NoCopyStruct from the provided WireView reader, using the specified flag to determine whether to ignore critical fields during parsing.
func ParseNoCopyStruct(reader enc.WireView, ignoreCritical bool) (*NoCopyStruct, error) {
	context := NoCopyStructParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StrFieldEncoder struct {
	Length uint
}

type StrFieldParsingContext struct {
}

// Calculates the total encoded length of a StrField, including mandatory Str1 and optional Str2, and sets it on the encoder for subsequent serialization.
func (encoder *StrFieldEncoder) Init(value *StrField) {

	l := uint(0)
	l += 1
	l += uint(enc.TLNum(len(value.Str1)).EncodingLength())
	l += uint(len(value.Str1))
	if optval, ok := value.Str2.Get(); ok {
		l += 1
		l += uint(enc.TLNum(len(optval)).EncodingLength())
		l += uint(len(optval))
	}
	encoder.Length = l

}

// Initializes the string field parsing context with default settings.
func (context *StrFieldParsingContext) Init() {

}

// Encodes a StrField struct into a binary buffer using a TLV (Type-Length-Value) format, where Str1 is required (tag 1) and Str2 is optional (tag 2) with presence indicated by inclusion.
func (encoder *StrFieldEncoder) EncodeInto(value *StrField, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(1)
	pos += 1
	pos += uint(enc.TLNum(len(value.Str1)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Str1)
	pos += uint(len(value.Str1))
	if optval, ok := value.Str2.Get(); ok {
		buf[pos] = byte(2)
		pos += 1
		pos += uint(enc.TLNum(len(optval)).EncodeInto(buf[pos:]))
		copy(buf[pos:], optval)
		pos += uint(len(optval))
	}
}

// Encodes a string field into a byte slice of the specified length, returning it as a wire structure.
func (encoder *StrFieldEncoder) Encode(value *StrField) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded StrField from the provided WireView reader, handling required fields Str1 (type 1) and optional Str2 (type 2), with critical field validation controlled by ignoreCritical.
func (context *StrFieldParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*StrField, error) {

	var handled_Str1 bool = false
	var handled_Str2 bool = false

	progress := -1
	_ = progress

	value := &StrField{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Str1 = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Str1 = builder.String()
						}
					}
				}
			case 2:
				if true {
					handled = true
					handled_Str2 = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Str2.Set(builder.String())
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Str1 && err == nil {
		err = enc.ErrSkipRequired{Name: "Str1", TypeNum: 1}
	}
	if !handled_Str2 && err == nil {
		value.Str2.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the string field value into a wire format using a StrFieldEncoder.
func (value *StrField) Encode() enc.Wire {
	encoder := StrFieldEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// "Returns the byte representation of the string field by encoding its value and concatenating the resulting byte slices."
func (value *StrField) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a string field from wire-format data, with an option to ignore critical fields that cannot be parsed.
func ParseStrField(reader enc.WireView, ignoreCritical bool) (*StrField, error) {
	context := StrFieldParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FixedUintFieldEncoder struct {
	Length uint
}

type FixedUintFieldParsingContext struct {
}

// Initializes the encoder's length by calculating the total size required to encode the FixedUintField, accounting for mandatory overhead and optional fields (U32, U64, BytePtr) when present.
func (encoder *FixedUintFieldEncoder) Init(value *FixedUintField) {

	l := uint(0)
	l += 1
	l += 1 + 1
	if value.U32.IsSet() {
		l += 1
		l += 1 + 4
	}
	if value.U64.IsSet() {
		l += 1
		l += 1 + 8
	}
	if value.BytePtr != nil {
		l += 1
		l += 2
	}
	encoder.Length = l

}

// Initializes the parsing context for fixed unsigned integer fields, serving as a base method that may be overridden by subclasses to provide specific initialization logic.
func (context *FixedUintFieldParsingContext) Init() {

}

// Encodes the FixedUintField into the provided buffer using a TLV (Type-Length-Value) format, including optional U32, U64, and BytePtr fields when present.
func (encoder *FixedUintFieldEncoder) EncodeInto(value *FixedUintField, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(1)
	pos += 1
	buf[pos] = 1
	buf[pos+1] = byte(value.Byte)
	pos += 2
	if optval, ok := value.U32.Get(); ok {
		buf[pos] = byte(2)
		pos += 1
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(optval))
		pos += 5
	}
	if optval, ok := value.U64.Get(); ok {
		buf[pos] = byte(3)
		pos += 1
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(optval))
		pos += 9
	}
	if value.BytePtr != nil {
		buf[pos] = byte(4)
		pos += 1
		buf[pos] = 1
		buf[pos+1] = byte(*value.BytePtr)
		pos += 2
	}
}

// Encodes a fixed-size unsigned integer field into a byte slice of length specified by the encoder and returns it as an NDN wire format structure.
func (encoder *FixedUintFieldEncoder) Encode(value *FixedUintField) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary-encoded FixedUintField structure, decoding required and optional unsigned integer fields (Byte, U32, U64, BytePtr) based on TLV-type identifiers, with critical field validation controlled by the ignoreCritical flag.
func (context *FixedUintFieldParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FixedUintField, error) {

	var handled_Byte bool = false
	var handled_U32 bool = false
	var handled_U64 bool = false
	var handled_BytePtr bool = false

	progress := -1
	_ = progress

	value := &FixedUintField{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Byte = true
					value.Byte, err = reader.ReadByte()
					if err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
				}
			case 2:
				if true {
					handled = true
					handled_U32 = true
					{
						optval := uint32(0)
						optval = uint32(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint32(optval<<8) | uint32(x)
							}
						}
						value.U32.Set(optval)
					}
				}
			case 3:
				if true {
					handled = true
					handled_U64 = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.U64.Set(optval)
					}
				}
			case 4:
				if true {
					handled = true
					handled_BytePtr = true
					{
						buf, err := reader.ReadBuf(1)
						if err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						value.BytePtr = &buf[0]
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Byte && err == nil {
		err = enc.ErrSkipRequired{Name: "Byte", TypeNum: 1}
	}
	if !handled_U32 && err == nil {
		value.U32.Unset()
	}
	if !handled_U64 && err == nil {
		value.U64.Unset()
	}
	if !handled_BytePtr && err == nil {
		value.BytePtr = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FixedUintField value into a wire format by initializing and executing a FixedUintFieldEncoder.
func (value *FixedUintField) Encode() enc.Wire {
	encoder := FixedUintFieldEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the concatenated byte representation of the encoded fixed unsigned integer field.
func (value *FixedUintField) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a fixed unsigned integer field from the provided encoded data using a parsing context, returning the parsed field and any encountered error.
func ParseFixedUintField(reader enc.WireView, ignoreCritical bool) (*FixedUintField, error) {
	context := FixedUintFieldParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
