// Code generated by ndn tlv codegen DO NOT EDIT.
package gen_composition

import (
	"io"

	enc "github.com/named-data/ndnd/std/encoding"
)

type IntArrayEncoder struct {
	Length uint

	Words_subencoder []struct {
	}
}

type IntArrayParsingContext struct {
}

// Initializes an IntArrayEncoder by calculating the total encoded length of the provided IntArray, accounting for each uint64 word's variable-length encoding and sequence overhead.
func (encoder *IntArrayEncoder) Init(value *IntArray) {
	{
		Words_l := len(value.Words)
		encoder.Words_subencoder = make([]struct {
		}, Words_l)
		for i := 0; i < Words_l; i++ {
			pseudoEncoder := &encoder.Words_subencoder[i]
			pseudoValue := struct {
				Words uint64
			}{
				Words: value.Words[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Words != nil {
		for seq_i, seq_v := range value.Words {
			pseudoEncoder := &encoder.Words_subencoder[seq_i]
			pseudoValue := struct {
				Words uint64
			}{
				Words: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(1 + enc.Nat(value.Words).EncodingLength())
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the IntArrayParsingContext, preparing it for parsing integer arrays.
func (context *IntArrayParsingContext) Init() {

}

// Encodes the elements of an IntArray's Words slice into a binary buffer, with each element prefixed by a type marker (0x01) and variable-length encoded as a uint64.
func (encoder *IntArrayEncoder) EncodeInto(value *IntArray, buf []byte) {

	pos := uint(0)

	if value.Words != nil {
		for seq_i, seq_v := range value.Words {
			pseudoEncoder := &encoder.Words_subencoder[seq_i]
			pseudoValue := struct {
				Words uint64
			}{
				Words: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(1)
				pos += 1

				buf[pos] = byte(enc.Nat(value.Words).EncodeInto(buf[pos+1:]))
				pos += uint(1 + buf[pos])
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes an IntArray into a byte slice of the specified length and returns it as a Wire structure.
func (encoder *IntArrayEncoder) Encode(value *IntArray) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded integer array, extracting sequences of bytes as uint64 words for type 1 fields and skipping or rejecting unrecognized/critical fields based on the ignoreCritical flag.
func (context *IntArrayParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*IntArray, error) {

	var handled_Words bool = false

	progress := -1
	_ = progress

	value := &IntArray{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Words = true
					if value.Words == nil {
						value.Words = make([]uint64, 0)
					}
					{
						pseudoValue := struct {
							Words uint64
						}{}
						{
							value := &pseudoValue
							value.Words = uint64(0)
							{
								for i := 0; i < int(l); i++ {
									x := byte(0)
									x, err = reader.ReadByte()
									if err != nil {
										if err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										break
									}
									value.Words = uint64(value.Words<<8) | uint64(x)
								}
							}
							_ = value
						}
						value.Words = append(value.Words, pseudoValue.Words)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Words && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the integer array into a wire format using an IntArrayEncoder.
func (value *IntArray) Encode() enc.Wire {
	encoder := IntArrayEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the concatenated byte representation of the integer array by encoding each element and joining them.
func (value *IntArray) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded integer array into an IntArray structure, optionally ignoring critical components based on the provided flag.
func ParseIntArray(reader enc.WireView, ignoreCritical bool) (*IntArray, error) {
	context := IntArrayParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NameArrayEncoder struct {
	Length uint

	Names_subencoder []struct {
		Names_length uint
	}
}

type NameArrayParsingContext struct {
}

// Initializes the NameArrayEncoder by computing the total encoded length of the provided NameArray, including TLV header overhead and individual name component lengths.
func (encoder *NameArrayEncoder) Init(value *NameArray) {
	{
		Names_l := len(value.Names)
		encoder.Names_subencoder = make([]struct {
			Names_length uint
		}, Names_l)
		for i := 0; i < Names_l; i++ {
			pseudoEncoder := &encoder.Names_subencoder[i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: value.Names[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					encoder.Names_length = 0
					for _, c := range value.Names {
						encoder.Names_length += uint(c.EncodingLength())
					}
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Names_length).EncodingLength())
					l += encoder.Names_length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the `NameArrayParsingContext`, setting up its state to begin parsing name arrays.
func (context *NameArrayParsingContext) Init() {

}

// Encodes a sequence of names from a NameArray into a binary buffer using TLV (Type-Length-Value) format, where each name is prefixed by a type byte (7), its length, and then its encoded components.
func (encoder *NameArrayEncoder) EncodeInto(value *NameArray, buf []byte) {

	pos := uint(0)

	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					buf[pos] = byte(7)
					pos += 1
					pos += uint(enc.TLNum(encoder.Names_length).EncodeInto(buf[pos:]))
					for _, c := range value.Names {
						pos += uint(c.EncodeInto(buf[pos:]))
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a NameArray into a TLV wire format by allocating a buffer of the encoder's specified length and populating it with the encoded array data.
func (encoder *NameArrayEncoder) Encode(value *NameArray) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded NameArray from a wire format, extracting Name components (type 7) into a slice and skipping or rejecting unknown critical types based on the ignoreCritical flag.
func (context *NameArrayParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NameArray, error) {

	var handled_Names bool = false

	progress := -1
	_ = progress

	value := &NameArray{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Names = true
					if value.Names == nil {
						value.Names = make([]enc.Name, 0)
					}
					{
						pseudoValue := struct {
							Names enc.Name
						}{}
						{
							value := &pseudoValue
							delegate := reader.Delegate(int(l))
							value.Names, err = delegate.ReadName()
							_ = value
						}
						value.Names = append(value.Names, pseudoValue.Names)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Names && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the NameArray into a wire-encoded format using a NameArrayEncoder.
func (value *NameArray) Encode() enc.Wire {
	encoder := NameArrayEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the NameArray by encoding each component and joining them into a single byte slice.
func (value *NameArray) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a NameArray from encoded wire format data, with an option to ignore critical parsing errors.
func ParseNameArray(reader enc.WireView, ignoreCritical bool) (*NameArray, error) {
	context := NameArrayParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type InnerEncoder struct {
	Length uint
}

type InnerParsingContext struct {
}

// Initializes the encoder's total length based on the encoded size of the Num field in the Inner value, including fixed overhead.
func (encoder *InnerEncoder) Init(value *Inner) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Num).EncodingLength())
	encoder.Length = l

}

// Initializes the inner parsing context for subsequent parsing operations.
func (context *InnerParsingContext) Init() {

}

// Encodes the `Inner` struct into a binary buffer using NDN's TLV format, writing a fixed type byte (1) followed by the variable-length encoded natural number representation of the `Num` field.
func (encoder *InnerEncoder) EncodeInto(value *Inner, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(1)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Num).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes the provided Inner value into a byte slice of the pre-determined length using the encoder's buffer, returning a wire-ready representation for transmission.
func (encoder *InnerEncoder) Encode(value *Inner) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded binary structure into an Inner object, decoding a required 'Num' field as a variable-length unsigned integer and conditionally skipping unrecognized or critical fields based on the ignoreCritical flag.
func (context *InnerParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Inner, error) {

	var handled_Num bool = false

	progress := -1
	_ = progress

	value := &Inner{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Num = true
					value.Num = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Num = uint64(value.Num<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Num && err == nil {
		err = enc.ErrSkipRequired{Name: "Num", TypeNum: 1}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the Inner instance into its wire format representation using an InnerEncoder.
func (value *Inner) Encode() enc.Wire {
	encoder := InnerEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte slice formed by encoding the Inner value and concatenating the resulting components.
func (value *Inner) Bytes() []byte {
	return value.Encode().Join()
}

// Parses wire-encoded data into an Inner structure, optionally ignoring critical fields based on the provided flag.
func ParseInner(reader enc.WireView, ignoreCritical bool) (*Inner, error) {
	context := InnerParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NestedEncoder struct {
	Length uint

	Val_encoder InnerEncoder
}

type NestedParsingContext struct {
	Val_context InnerParsingContext
}

// Initializes the NestedEncoder with the provided Nested value, calculating its encoded length by summing the type byte, encoded length field size, and the length of the nested value's content.
func (encoder *NestedEncoder) Init(value *Nested) {
	if value.Val != nil {
		encoder.Val_encoder.Init(value.Val)
	}

	l := uint(0)
	if value.Val != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Val_encoder.Length).EncodingLength())
		l += encoder.Val_encoder.Length
	}
	encoder.Length = l

}

// Initializes the internal Val_context component of the NestedParsingContext by calling its Init method.
func (context *NestedParsingContext) Init() {
	context.Val_context.Init()
}

// Encodes a Nested object into a TLV (Type-Length-Value) format in the provided buffer, handling the presence of the Val field with a type indicator (byte 2), length encoding, and value serialization.
func (encoder *NestedEncoder) EncodeInto(value *Nested, buf []byte) {

	pos := uint(0)

	if value.Val != nil {
		buf[pos] = byte(2)
		pos += 1
		pos += uint(enc.TLNum(encoder.Val_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Val_encoder.Length > 0 {
			encoder.Val_encoder.EncodeInto(value.Val, buf[pos:])
			pos += encoder.Val_encoder.Length
		}
	}
}

// Encodes a Nested object into a byte slice using the encoder's pre-allocated buffer size and returns it as a single-element Wire slice.
func (encoder *NestedEncoder) Encode(value *Nested) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded Nested structure from the provided wire reader, handling the "Val" field with the associated context and skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *NestedParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Nested, error) {

	var handled_Val bool = false

	progress := -1
	_ = progress

	value := &Nested{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 2:
				if true {
					handled = true
					handled_Val = true
					value.Val, err = context.Val_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Val && err == nil {
		value.Val = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the Nested value into a wire format using a NestedEncoder.
func (value *Nested) Encode() enc.Wire {
	encoder := NestedEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// **Returns the byte slice representing the wire-format encoding of the Nested value.**
func (value *Nested) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a nested structure from the provided wire format data, using the given parsing context and optionally ignoring critical elements.
func ParseNested(reader enc.WireView, ignoreCritical bool) (*Nested, error) {
	context := NestedParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NestedSeqEncoder struct {
	Length uint

	Vals_subencoder []struct {
		Vals_encoder InnerEncoder
	}
}

type NestedSeqParsingContext struct {
	Vals_context InnerParsingContext
}

// Initializes sub-encoders for each element in a nested sequence structure and computes the total encoded length, including TLV encoding overhead, to prepare for efficient NDN data encoding.
func (encoder *NestedSeqEncoder) Init(value *NestedSeq) {
	{
		Vals_l := len(value.Vals)
		encoder.Vals_subencoder = make([]struct {
			Vals_encoder InnerEncoder
		}, Vals_l)
		for i := 0; i < Vals_l; i++ {
			pseudoEncoder := &encoder.Vals_subencoder[i]
			pseudoValue := struct {
				Vals *Inner
			}{
				Vals: value.Vals[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					encoder.Vals_encoder.Init(value.Vals)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *Inner
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Vals_encoder.Length).EncodingLength())
					l += encoder.Vals_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the internal Vals_context within the NestedSeqParsingContext to prepare for parsing operations.
func (context *NestedSeqParsingContext) Init() {
	context.Vals_context.Init()
}

// Encodes a sequence of values from a NestedSeq structure into a binary buffer using a TLV (Type-Length-Value) format, with each element encoded by its corresponding subencoder.
func (encoder *NestedSeqEncoder) EncodeInto(value *NestedSeq, buf []byte) {

	pos := uint(0)

	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *Inner
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					buf[pos] = byte(3)
					pos += 1
					pos += uint(enc.TLNum(encoder.Vals_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Vals_encoder.Length > 0 {
						encoder.Vals_encoder.EncodeInto(value.Vals, buf[pos:])
						pos += encoder.Vals_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the given NestedSeq value into a binary wire format using the pre-determined length of the encoder.
func (encoder *NestedSeqEncoder) Encode(value *NestedSeq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded NestedSeq structure from the provided wire reader, using the Vals_context to decode the Vals field and handling critical/unrecognized fields according to the ignoreCritical flag.
func (context *NestedSeqParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NestedSeq, error) {

	var handled_Vals bool = false

	progress := -1
	_ = progress

	value := &NestedSeq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 3:
				if true {
					handled = true
					handled_Vals = true
					if value.Vals == nil {
						value.Vals = make([]*Inner, 0)
					}
					{
						pseudoValue := struct {
							Vals *Inner
						}{}
						{
							value := &pseudoValue
							value.Vals, err = context.Vals_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Vals = append(value.Vals, pseudoValue.Vals)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Vals && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the NestedSeq value into a wire format using a NestedSeqEncoder for serialization.
func (value *NestedSeq) Encode() enc.Wire {
	encoder := NestedSeqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the NestedSeq into a contiguous byte slice by joining its encoded components.
func (value *NestedSeq) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a nested TLV sequence from the provided wire format data into a `NestedSeq` structure, using the given parsing context and optionally ignoring critical elements based on the `ignoreCritical` flag.
func ParseNestedSeq(reader enc.WireView, ignoreCritical bool) (*NestedSeq, error) {
	context := NestedSeqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type InnerWire1Encoder struct {
	Length uint

	wirePlan []uint

	Wire1_length uint
}

type InnerWire1ParsingContext struct {
}

// Initializes the encoder with the total encoded length and a wire encoding plan for the InnerWire1 structure, accounting for optional fields and nested string lengths.
func (encoder *InnerWire1Encoder) Init(value *InnerWire1) {
	if value.Wire1 != nil {
		encoder.Wire1_length = 0
		for _, c := range value.Wire1 {
			encoder.Wire1_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.Wire1 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire1_length).EncodingLength())
		l += encoder.Wire1_length
	}
	if optval, ok := value.Num.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Wire1 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire1_length).EncodingLength())
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Wire1 {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	if optval, ok := value.Num.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the InnerWire1ParsingContext for parsing NDN packets.
func (context *InnerWire1ParsingContext) Init() {

}

// Encodes an `InnerWire1` struct into a binary wire format using TLV (Type-Length-Value) encoding, handling a slice of wire elements (type 1) and an optional unsigned integer (type 2).
func (encoder *InnerWire1Encoder) EncodeInto(value *InnerWire1, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.Wire1 != nil {
		buf[pos] = byte(1)
		pos += 1
		pos += uint(enc.TLNum(encoder.Wire1_length).EncodeInto(buf[pos:]))
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Wire1 {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
	if optval, ok := value.Num.Get(); ok {
		buf[pos] = byte(2)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
}

// Encodes an `InnerWire1` value into a pre-allocated byte slice structure defined by the encoder's wire plan, returning a segmented wire representation.
func (encoder *InnerWire1Encoder) Encode(value *InnerWire1) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a TLV-encoded binary structure into an `InnerWire1` object, handling specific fields (Wire1 and Num) and skipping or rejecting unknown critical types based on the `ignoreCritical` flag.
func (context *InnerWire1ParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*InnerWire1, error) {

	var handled_Wire1 bool = false
	var handled_Num bool = false

	progress := -1
	_ = progress

	value := &InnerWire1{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1:
				if true {
					handled = true
					handled_Wire1 = true
					value.Wire1, err = reader.ReadWire(int(l))
				}
			case 2:
				if true {
					handled = true
					handled_Num = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Num.Set(optval)
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Wire1 && err == nil {
		value.Wire1 = nil
	}
	if !handled_Num && err == nil {
		value.Num.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

type InnerWire2Encoder struct {
	Length uint

	wirePlan []uint

	Wire2_length uint
}

type InnerWire2ParsingContext struct {
}

// Initializes the encoder with length calculations and encoding plan for the `Wire2` field, accounting for variable-length encoding of its contents.
func (encoder *InnerWire2Encoder) Init(value *InnerWire2) {
	if value.Wire2 != nil {
		encoder.Wire2_length = 0
		for _, c := range value.Wire2 {
			encoder.Wire2_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.Wire2 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire2_length).EncodingLength())
		l += encoder.Wire2_length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Wire2 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Wire2_length).EncodingLength())
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Wire2 {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the InnerWire2ParsingContext, preparing it for subsequent parsing operations (currently no implementation).
func (context *InnerWire2ParsingContext) Init() {

}

// Encodes the `Wire2` field of the provided `InnerWire2` value into the given wire buffer using TLV (Type-Length-Value) encoding, writing a type byte `3`, the length of the `Wire2` slice, and its elements into sequential wire segments.
func (encoder *InnerWire2Encoder) EncodeInto(value *InnerWire2, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.Wire2 != nil {
		buf[pos] = byte(3)
		pos += 1
		pos += uint(enc.TLNum(encoder.Wire2_length).EncodeInto(buf[pos:]))
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Wire2 {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
}

// Encodes the provided InnerWire2 value into a pre-allocated byte slice structure based on a predefined wire layout plan, returning the segmented encoded data as an enc.Wire.
func (encoder *InnerWire2Encoder) Encode(value *InnerWire2) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a TLV-encoded InnerWire2 object from the provided byte stream, extracting the Wire2 field (type 3) and skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *InnerWire2ParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*InnerWire2, error) {

	var handled_Wire2 bool = false

	progress := -1
	_ = progress

	value := &InnerWire2{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 3:
				if true {
					handled = true
					handled_Wire2 = true
					value.Wire2, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Wire2 && err == nil {
		value.Wire2 = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

type NestedWireEncoder struct {
	Length uint

	wirePlan []uint

	W1_encoder InnerWire1Encoder

	W2_encoder InnerWire2Encoder
}

type NestedWireParsingContext struct {
	W1_context InnerWire1ParsingContext

	W2_context InnerWire2ParsingContext
}

// Initializes the NestedWireEncoder with the provided NestedWire structure, calculates the total encoded length, and constructs a wire plan detailing the encoding offsets for each component (W1, N, W2) to facilitate structured wire format serialization.
func (encoder *NestedWireEncoder) Init(value *NestedWire) {
	if value.W1 != nil {
		encoder.W1_encoder.Init(value.W1)
	}

	if value.W2 != nil {
		encoder.W2_encoder.Init(value.W2)
	}

	l := uint(0)
	if value.W1 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.W1_encoder.Length).EncodingLength())
		l += encoder.W1_encoder.Length
	}
	l += 1
	l += uint(1 + enc.Nat(value.N).EncodingLength())
	if value.W2 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.W2_encoder.Length).EncodingLength())
		l += encoder.W2_encoder.Length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.W1 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.W1_encoder.Length).EncodingLength())
		if encoder.W1_encoder.Length > 0 {
			l += encoder.W1_encoder.wirePlan[0]
			for i := 1; i < len(encoder.W1_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.W1_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	l += 1
	l += uint(1 + enc.Nat(value.N).EncodingLength())
	if value.W2 != nil {
		l += 1
		l += uint(enc.TLNum(encoder.W2_encoder.Length).EncodingLength())
		if encoder.W2_encoder.Length > 0 {
			l += encoder.W2_encoder.wirePlan[0]
			for i := 1; i < len(encoder.W2_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.W2_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the nested wire parsing context by initializing its internal W1 and W2 sub-contexts for wire parsing operations.
func (context *NestedWireParsingContext) Init() {
	context.W1_context.Init()

	context.W2_context.Init()
}

// Encodes a NestedWire structure into a binary wire format using TLV encoding, handling nested fields (W1, W2) by delegating to sub-encoders and managing buffer layout with type markers, length fields, and value serialization.
func (encoder *NestedWireEncoder) EncodeInto(value *NestedWire, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.W1 != nil {
		buf[pos] = byte(4)
		pos += 1
		pos += uint(enc.TLNum(encoder.W1_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.W1_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.W1_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.W1_encoder.EncodeInto(value.W1, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.W1_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
	buf[pos] = byte(5)
	pos += 1

	buf[pos] = byte(enc.Nat(value.N).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.W2 != nil {
		buf[pos] = byte(6)
		pos += 1
		pos += uint(enc.TLNum(encoder.W2_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.W2_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.W2_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.W2_encoder.EncodeInto(value.W2, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.W2_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
}

// Encodes a NestedWire value into a pre-allocated, segmented byte slice structure according to the encoder's wire plan, returning the structured wire representation.
func (encoder *NestedWireEncoder) Encode(value *NestedWire) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a binary TLV-encoded structure into a NestedWire object, handling nested W1 and W2 fields, a required uint64 N field, and managing critical vs non-critical TLV types based on the ignoreCritical flag.
func (context *NestedWireParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NestedWire, error) {

	var handled_W1 bool = false
	var handled_N bool = false
	var handled_W2 bool = false

	progress := -1
	_ = progress

	value := &NestedWire{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 4:
				if true {
					handled = true
					handled_W1 = true
					value.W1, err = context.W1_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 5:
				if true {
					handled = true
					handled_N = true
					value.N = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.N = uint64(value.N<<8) | uint64(x)
						}
					}
				}
			case 6:
				if true {
					handled = true
					handled_W2 = true
					value.W2, err = context.W2_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_W1 && err == nil {
		value.W1 = nil
	}
	if !handled_N && err == nil {
		err = enc.ErrSkipRequired{Name: "N", TypeNum: 5}
	}
	if !handled_W2 && err == nil {
		value.W2 = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the NestedWire value into a wire format using a NestedWireEncoder.
func (value *NestedWire) Encode() enc.Wire {
	encoder := NestedWireEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte representation of the NestedWire value by encoding its components and joining them into a single byte slice.
func (value *NestedWire) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a nested wire-encoded structure into a NestedWire object, optionally ignoring critical elements that cannot be processed.
func ParseNestedWire(reader enc.WireView, ignoreCritical bool) (*NestedWire, error) {
	context := NestedWireParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
