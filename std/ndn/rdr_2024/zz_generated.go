// Code generated by ndn tlv codegen DO NOT EDIT.
package rdr

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type ManifestDigestEncoder struct {
	Length uint
}

type ManifestDigestParsingContext struct {
}

// Initializes the encoder by calculating the total encoded length of the ManifestDigest, including 1 byte for the SegNo field, the TLV-encoded length of the segment number, and optionally 1 byte plus the TLV-encoded length and raw bytes of the digest if present.
func (encoder *ManifestDigestEncoder) Init(value *ManifestDigest) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.SegNo).EncodingLength())
	if value.Digest != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Digest)).EncodingLength())
		l += uint(len(value.Digest))
	}
	encoder.Length = l

}

// Initializes the parsing context for processing a manifest digest, preparing it for subsequent parsing operations.
func (context *ManifestDigestParsingContext) Init() {

}

// Encodes a ManifestDigest into a binary TLV (Type-Length-Value) format in the provided buffer, with type 204 for the segment number (SegNo) and type 206 for the optional digest field.
func (encoder *ManifestDigestEncoder) EncodeInto(value *ManifestDigest, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(204)
	pos += 1

	buf[pos] = byte(enc.Nat(value.SegNo).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Digest != nil {
		buf[pos] = byte(206)
		pos += 1
		pos += uint(enc.TLNum(len(value.Digest)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Digest)
		pos += uint(len(value.Digest))
	}
}

// Encodes a ManifestDigest into a binary wire format using the pre-determined buffer length of the encoder.
func (encoder *ManifestDigestEncoder) Encode(value *ManifestDigest) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded manifest digest from a wire format reader, extracting the segment number (type 204) and digest (type 206) fields while handling critical/non-critical fields according to the ignoreCritical flag.
func (context *ManifestDigestParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ManifestDigest, error) {

	var handled_SegNo bool = false
	var handled_Digest bool = false

	progress := -1
	_ = progress

	value := &ManifestDigest{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 204:
				if true {
					handled = true
					handled_SegNo = true
					value.SegNo = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.SegNo = uint64(value.SegNo<<8) | uint64(x)
						}
					}
				}
			case 206:
				if true {
					handled = true
					handled_Digest = true
					value.Digest = make([]byte, l)
					_, err = reader.ReadFull(value.Digest)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_SegNo && err == nil {
		err = enc.ErrSkipRequired{Name: "SegNo", TypeNum: 204}
	}
	if !handled_Digest && err == nil {
		value.Digest = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the ManifestDigest value into its corresponding NDN wire format representation using the ManifestDigestEncoder.
func (value *ManifestDigest) Encode() enc.Wire {
	encoder := ManifestDigestEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the ManifestDigest as a single byte slice by encoding its value and joining the resulting components.
func (value *ManifestDigest) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a ManifestDigest from the provided encoded wire format data, optionally ignoring critical parameters that cannot be processed.
func ParseManifestDigest(reader enc.WireView, ignoreCritical bool) (*ManifestDigest, error) {
	context := ManifestDigestParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ManifestDataEncoder struct {
	Length uint

	Entries_subencoder []struct {
		Entries_encoder ManifestDigestEncoder
	}
}

type ManifestDataParsingContext struct {
	Entries_context ManifestDigestParsingContext
}

// Initializes encoders for each entry in the manifest data and calculates the total encoded length, including TLV overhead for a TLV-based encoding scheme.
func (encoder *ManifestDataEncoder) Init(value *ManifestData) {
	{
		Entries_l := len(value.Entries)
		encoder.Entries_subencoder = make([]struct {
			Entries_encoder ManifestDigestEncoder
		}, Entries_l)
		for i := 0; i < Entries_l; i++ {
			pseudoEncoder := &encoder.Entries_subencoder[i]
			pseudoValue := struct {
				Entries *ManifestDigest
			}{
				Entries: value.Entries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					encoder.Entries_encoder.Init(value.Entries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *ManifestDigest
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Entries_encoder.Length).EncodingLength())
					l += encoder.Entries_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the entries context within the ManifestDataParsingContext instance.
func (context *ManifestDataParsingContext) Init() {
	context.Entries_context.Init()
}

// Encodes the entries of a ManifestData structure into a binary buffer using TLV (Type-Length-Value) encoding, where each entry is prefixed by a type byte (202) and its encoded length.
func (encoder *ManifestDataEncoder) EncodeInto(value *ManifestData, buf []byte) {

	pos := uint(0)

	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *ManifestDigest
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					buf[pos] = byte(202)
					pos += 1
					pos += uint(enc.TLNum(encoder.Entries_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Entries_encoder.Length > 0 {
						encoder.Entries_encoder.EncodeInto(value.Entries, buf[pos:])
						pos += encoder.Entries_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Serializes the provided `ManifestData` into a wire-encoded byte slice using the pre-allocated buffer size specified by the encoder's `Length` field.
func (encoder *ManifestDataEncoder) Encode(value *ManifestData) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded manifest data into a ManifestData structure, handling critical and non-critical fields according to the provided context and ignoreCritical flag.
func (context *ManifestDataParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ManifestData, error) {

	var handled_Entries bool = false

	progress := -1
	_ = progress

	value := &ManifestData{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 202:
				if true {
					handled = true
					handled_Entries = true
					if value.Entries == nil {
						value.Entries = make([]*ManifestDigest, 0)
					}
					{
						pseudoValue := struct {
							Entries *ManifestDigest
						}{}
						{
							value := &pseudoValue
							value.Entries, err = context.Entries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Entries = append(value.Entries, pseudoValue.Entries)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Entries && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the ManifestData into a wire format using the ManifestDataEncoder.
func (value *ManifestData) Encode() enc.Wire {
	encoder := ManifestDataEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Serializes the ManifestData into a byte slice by encoding its components and concatenating the results.
func (value *ManifestData) Bytes() []byte {
	return value.Encode().Join()
}

// Parses encoded manifest data from the given reader into a ManifestData object, optionally ignoring critical parsing errors.
func ParseManifestData(reader enc.WireView, ignoreCritical bool) (*ManifestData, error) {
	context := ManifestDataParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type MetaDataEncoder struct {
	Length uint

	Name_length uint
}

type MetaDataParsingContext struct {
}

// Initializes the MetaDataEncoder by calculating the total encoded length of the provided MetaData, accounting for all mandatory and optional fields using TLV (Type-Length-Value) encoding rules.
func (encoder *MetaDataEncoder) Init(value *MetaData) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	if value.FinalBlockID != nil {
		l += 1
		l += uint(enc.TLNum(len(value.FinalBlockID)).EncodingLength())
		l += uint(len(value.FinalBlockID))
	}
	if optval, ok := value.SegmentSize.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Size.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Mode.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Atime.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Btime.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Ctime.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.Mtime.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.ObjectType.Get(); ok {
		l += 3
		l += uint(enc.TLNum(len(optval)).EncodingLength())
		l += uint(len(optval))
	}
	encoder.Length = l

}

// Initializes the metadata parsing context, preparing it for subsequent metadata processing operations (currently a no-op placeholder).
func (context *MetaDataParsingContext) Init() {

}

// Encodes a MetaData structure into a binary buffer using NDN TLV format, including standard fields like Name and FinalBlockID, and optional metadata attributes (e.g., SegmentSize, Size, Mode) with their respective attribute numbers and variable-length numeric or byte-string values.
func (encoder *MetaDataEncoder) EncodeInto(value *MetaData, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.FinalBlockID != nil {
		buf[pos] = byte(26)
		pos += 1
		pos += uint(enc.TLNum(len(value.FinalBlockID)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.FinalBlockID)
		pos += uint(len(value.FinalBlockID))
	}
	if optval, ok := value.SegmentSize.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62720))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Size.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62722))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Mode.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62724))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Atime.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62726))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Btime.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62728))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Ctime.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62730))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.Mtime.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62732))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.ObjectType.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(62734))
		pos += 3
		pos += uint(enc.TLNum(len(optval)).EncodeInto(buf[pos:]))
		copy(buf[pos:], optval)
		pos += uint(len(optval))
	}
}

// Encodes the provided MetaData into a byte slice using the encoder's calculated length and returns it as a single-element enc.Wire structure.
func (encoder *MetaDataEncoder) Encode(value *MetaData) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded metadata from a wire format reader into a MetaData object, handling known fields (e.g., Name, timestamps, file sizes) and managing unknown fields according to the ignoreCritical flag.
func (context *MetaDataParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*MetaData, error) {

	var handled_Name bool = false
	var handled_FinalBlockID bool = false
	var handled_SegmentSize bool = false
	var handled_Size bool = false
	var handled_Mode bool = false
	var handled_Atime bool = false
	var handled_Btime bool = false
	var handled_Ctime bool = false
	var handled_Mtime bool = false
	var handled_ObjectType bool = false

	progress := -1
	_ = progress

	value := &MetaData{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			case 26:
				if true {
					handled = true
					handled_FinalBlockID = true
					value.FinalBlockID = make([]byte, l)
					_, err = reader.ReadFull(value.FinalBlockID)
				}
			case 62720:
				if true {
					handled = true
					handled_SegmentSize = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.SegmentSize.Set(optval)
					}
				}
			case 62722:
				if true {
					handled = true
					handled_Size = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Size.Set(optval)
					}
				}
			case 62724:
				if true {
					handled = true
					handled_Mode = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Mode.Set(optval)
					}
				}
			case 62726:
				if true {
					handled = true
					handled_Atime = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Atime.Set(optval)
					}
				}
			case 62728:
				if true {
					handled = true
					handled_Btime = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Btime.Set(optval)
					}
				}
			case 62730:
				if true {
					handled = true
					handled_Ctime = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Ctime.Set(optval)
					}
				}
			case 62732:
				if true {
					handled = true
					handled_Mtime = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Mtime.Set(optval)
					}
				}
			case 62734:
				if true {
					handled = true
					handled_ObjectType = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.ObjectType.Set(builder.String())
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_FinalBlockID && err == nil {
		value.FinalBlockID = nil
	}
	if !handled_SegmentSize && err == nil {
		value.SegmentSize.Unset()
	}
	if !handled_Size && err == nil {
		value.Size.Unset()
	}
	if !handled_Mode && err == nil {
		value.Mode.Unset()
	}
	if !handled_Atime && err == nil {
		value.Atime.Unset()
	}
	if !handled_Btime && err == nil {
		value.Btime.Unset()
	}
	if !handled_Ctime && err == nil {
		value.Ctime.Unset()
	}
	if !handled_Mtime && err == nil {
		value.Mtime.Unset()
	}
	if !handled_ObjectType && err == nil {
		value.ObjectType.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the MetaData into a wire format using a MetaDataEncoder for transmission or storage.
func (value *MetaData) Encode() enc.Wire {
	encoder := MetaDataEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the MetaData by encoding its components and concatenating them into a single byte slice.
func (value *MetaData) Bytes() []byte {
	return value.Encode().Join()
}

// Parses encoded metadata from a wire format using a parsing context, with an option to ignore critical fields that cannot be processed.
func ParseMetaData(reader enc.WireView, ignoreCritical bool) (*MetaData, error) {
	context := MetaDataParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
