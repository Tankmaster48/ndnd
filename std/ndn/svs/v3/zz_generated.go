// Code generated by ndn tlv codegen DO NOT EDIT.
package svs

import (
	"encoding/binary"
	"io"

	enc "github.com/named-data/ndnd/std/encoding"
)

type SvsDataEncoder struct {
	Length uint

	StateVector_encoder StateVectorEncoder
}

type SvsDataParsingContext struct {
	StateVector_context StateVectorParsingContext
}

// Initializes the encoder with the provided SVS data, computing the total encoded length by including the state vector's encoded size if present.
func (encoder *SvsDataEncoder) Init(value *SvsData) {
	if value.StateVector != nil {
		encoder.StateVector_encoder.Init(value.StateVector)
	}

	l := uint(0)
	if value.StateVector != nil {
		l += 1
		l += uint(enc.TLNum(encoder.StateVector_encoder.Length).EncodingLength())
		l += encoder.StateVector_encoder.Length
	}
	encoder.Length = l

}

// Initializes the internal state vector context associated with this parsing context.
func (context *SvsDataParsingContext) Init() {
	context.StateVector_context.Init()
}

// Encodes the `StateVector` field of the provided `SvsData` into the given byte buffer if non-nil, writing a type identifier (201), encoded length, and serialized state vector data.
func (encoder *SvsDataEncoder) EncodeInto(value *SvsData, buf []byte) {

	pos := uint(0)

	if value.StateVector != nil {
		buf[pos] = byte(201)
		pos += 1
		pos += uint(enc.TLNum(encoder.StateVector_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.StateVector_encoder.Length > 0 {
			encoder.StateVector_encoder.EncodeInto(value.StateVector, buf[pos:])
			pos += encoder.StateVector_encoder.Length
		}
	}
}

// Encodes the provided *SvsData into a byte slice of length equal to the encoder's Length field, returning it as a single-element enc.Wire.
func (encoder *SvsDataEncoder) Encode(value *SvsData) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded SVSData, extracting a StateVector field (type 201) and handling critical/unrecognized fields according to the ignoreCritical flag.
func (context *SvsDataParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*SvsData, error) {

	var handled_StateVector bool = false

	progress := -1
	_ = progress

	value := &SvsData{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 201:
				if true {
					handled = true
					handled_StateVector = true
					value.StateVector, err = context.StateVector_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_StateVector && err == nil {
		value.StateVector = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the SvsData instance into a wire-encoded format using the SvsDataEncoder for transmission or storage.
func (value *SvsData) Encode() enc.Wire {
	encoder := SvsDataEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the SVS data value into a byte slice.
func (value *SvsData) Bytes() []byte {
	return value.Encode().Join()
}

// Parses wire-format SVS data into an SvsData structure, optionally ignoring critical fields.
func ParseSvsData(reader enc.WireView, ignoreCritical bool) (*SvsData, error) {
	context := SvsDataParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StateVectorEncoder struct {
	Length uint

	Entries_subencoder []struct {
		Entries_encoder StateVectorEntryEncoder
	}
}

type StateVectorParsingContext struct {
	Entries_context StateVectorEntryParsingContext
}

// Initializes the StateVectorEncoder with the provided StateVector, setting up per-entry encoders and computing the total encoded length including TLV overhead for each entry.
func (encoder *StateVectorEncoder) Init(value *StateVector) {
	{
		Entries_l := len(value.Entries)
		encoder.Entries_subencoder = make([]struct {
			Entries_encoder StateVectorEntryEncoder
		}, Entries_l)
		for i := 0; i < Entries_l; i++ {
			pseudoEncoder := &encoder.Entries_subencoder[i]
			pseudoValue := struct {
				Entries *StateVectorEntry
			}{
				Entries: value.Entries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					encoder.Entries_encoder.Init(value.Entries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *StateVectorEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Entries_encoder.Length).EncodingLength())
					l += encoder.Entries_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the internal entries context of this state vector parsing context.
func (context *StateVectorParsingContext) Init() {
	context.Entries_context.Init()
}

// Encodes a StateVector into a TLV (Type-Length-Value) binary format by serializing each entry in its Entries map using corresponding subencoders, writing the result directly into the provided byte buffer.
func (encoder *StateVectorEncoder) EncodeInto(value *StateVector, buf []byte) {

	pos := uint(0)

	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *StateVectorEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					buf[pos] = byte(202)
					pos += 1
					pos += uint(enc.TLNum(encoder.Entries_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Entries_encoder.Length > 0 {
						encoder.Entries_encoder.EncodeInto(value.Entries, buf[pos:])
						pos += encoder.Entries_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the provided StateVector into a binary wire format using the encoder's configured length, returning the result as a slice of byte slices.
func (encoder *StateVectorEncoder) Encode(value *StateVector) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded StateVector from the provided reader, handling recognized entries (e.g., type 202) and skipping or rejecting unrecognized fields based on the ignoreCritical flag.
func (context *StateVectorParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*StateVector, error) {

	var handled_Entries bool = false

	progress := -1
	_ = progress

	value := &StateVector{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 202:
				if true {
					handled = true
					handled_Entries = true
					if value.Entries == nil {
						value.Entries = make([]*StateVectorEntry, 0)
					}
					{
						pseudoValue := struct {
							Entries *StateVectorEntry
						}{}
						{
							value := &pseudoValue
							value.Entries, err = context.Entries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Entries = append(value.Entries, pseudoValue.Entries)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Entries && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the StateVector into its wire format representation using the StateVectorEncoder.
func (value *StateVector) Encode() enc.Wire {
	encoder := StateVectorEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the StateVector and returns the resulting byte slice.
func (value *StateVector) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a StateVector from the provided WireView input, optionally ignoring critical fields that cannot be processed based on the ignoreCritical flag.
func ParseStateVector(reader enc.WireView, ignoreCritical bool) (*StateVector, error) {
	context := StateVectorParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StateVectorEntryEncoder struct {
	Length uint

	Name_length             uint
	SeqNoEntries_subencoder []struct {
		SeqNoEntries_encoder SeqNoEntryEncoder
	}
}

type StateVectorEntryParsingContext struct {
	SeqNoEntries_context SeqNoEntryParsingContext
}

// Initializes a StateVectorEntryEncoder with the provided StateVectorEntry value, calculating the total encoded length by aggregating the TLV-encoded sizes of its Name and SeqNoEntries fields.
func (encoder *StateVectorEntryEncoder) Init(value *StateVectorEntry) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}
	{
		SeqNoEntries_l := len(value.SeqNoEntries)
		encoder.SeqNoEntries_subencoder = make([]struct {
			SeqNoEntries_encoder SeqNoEntryEncoder
		}, SeqNoEntries_l)
		for i := 0; i < SeqNoEntries_l; i++ {
			pseudoEncoder := &encoder.SeqNoEntries_subencoder[i]
			pseudoValue := struct {
				SeqNoEntries *SeqNoEntry
			}{
				SeqNoEntries: value.SeqNoEntries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SeqNoEntries != nil {
					encoder.SeqNoEntries_encoder.Init(value.SeqNoEntries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	if value.SeqNoEntries != nil {
		for seq_i, seq_v := range value.SeqNoEntries {
			pseudoEncoder := &encoder.SeqNoEntries_subencoder[seq_i]
			pseudoValue := struct {
				SeqNoEntries *SeqNoEntry
			}{
				SeqNoEntries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SeqNoEntries != nil {
					l += 1
					l += uint(enc.TLNum(encoder.SeqNoEntries_encoder.Length).EncodingLength())
					l += encoder.SeqNoEntries_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the sequence number entries context within the state vector entry parsing context.
func (context *StateVectorEntryParsingContext) Init() {

	context.SeqNoEntries_context.Init()
}

// Encodes a StateVectorEntry struct into a binary buffer, serializing its Name field as a TLV-encoded NDN name component list and its SeqNoEntries as a sequence of TLV-encoded SeqNoEntry records.
func (encoder *StateVectorEntryEncoder) EncodeInto(value *StateVectorEntry, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.SeqNoEntries != nil {
		for seq_i, seq_v := range value.SeqNoEntries {
			pseudoEncoder := &encoder.SeqNoEntries_subencoder[seq_i]
			pseudoValue := struct {
				SeqNoEntries *SeqNoEntry
			}{
				SeqNoEntries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SeqNoEntries != nil {
					buf[pos] = byte(210)
					pos += 1
					pos += uint(enc.TLNum(encoder.SeqNoEntries_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.SeqNoEntries_encoder.Length > 0 {
						encoder.SeqNoEntries_encoder.EncodeInto(value.SeqNoEntries, buf[pos:])
						pos += encoder.SeqNoEntries_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a StateVectorEntry into a binary wire format using the encoder's pre-determined buffer length.  

Example: Converts a StateVectorEntry struct into a byte slice of fixed size (as defined by the encoder) for network transmission.
func (encoder *StateVectorEntryEncoder) Encode(value *StateVectorEntry) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded StateVectorEntry from the provided WireView reader, handling Name (type 7) and SeqNoEntries (type 210) fields using a recursive context-based approach, with optional critical field error handling.
func (context *StateVectorEntryParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*StateVectorEntry, error) {

	var handled_Name bool = false
	var handled_SeqNoEntries bool = false

	progress := -1
	_ = progress

	value := &StateVectorEntry{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			case 210:
				if true {
					handled = true
					handled_SeqNoEntries = true
					if value.SeqNoEntries == nil {
						value.SeqNoEntries = make([]*SeqNoEntry, 0)
					}
					{
						pseudoValue := struct {
							SeqNoEntries *SeqNoEntry
						}{}
						{
							value := &pseudoValue
							value.SeqNoEntries, err = context.SeqNoEntries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.SeqNoEntries = append(value.SeqNoEntries, pseudoValue.SeqNoEntries)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_SeqNoEntries && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the StateVectorEntry into its wire format representation for serialization or transmission.
func (value *StateVectorEntry) Encode() enc.Wire {
	encoder := StateVectorEntryEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// **Description:**  
Encodes the StateVectorEntry and joins the resulting components into a single byte slice.
func (value *StateVectorEntry) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a StateVectorEntry from wire format data, optionally ignoring critical parsing errors.
func ParseStateVectorEntry(reader enc.WireView, ignoreCritical bool) (*StateVectorEntry, error) {
	context := StateVectorEntryParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type SeqNoEntryEncoder struct {
	Length uint
}

type SeqNoEntryParsingContext struct {
}

// Initializes the encoder by calculating and setting the total encoded length of the SeqNoEntry, which includes fixed overhead and variable-length fields for the BootstrapTime and SeqNo natural numbers.
func (encoder *SeqNoEntryEncoder) Init(value *SeqNoEntry) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.BootstrapTime).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.SeqNo).EncodingLength())
	encoder.Length = l

}

// Initializes the sequence number entry parsing context.
func (context *SeqNoEntryParsingContext) Init() {

}

// Encodes a `SeqNoEntry` into the provided buffer using TLV format, with type 212 for `BootstrapTime` and type 214 for `SeqNo`, each prefixed by their encoded lengths.
func (encoder *SeqNoEntryEncoder) EncodeInto(value *SeqNoEntry, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(212)
	pos += 1

	buf[pos] = byte(enc.Nat(value.BootstrapTime).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(214)
	pos += 1

	buf[pos] = byte(enc.Nat(value.SeqNo).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes a sequence number entry (`SeqNoEntry`) into a binary wire format using the encoder's predefined buffer length, returning a slice containing the serialized byte array.
func (encoder *SeqNoEntryEncoder) Encode(value *SeqNoEntry) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded `SeqNoEntry` structure, requiring `BootstrapTime` (type 212) and `SeqNo` (type 214) fields, while optionally ignoring unknown critical fields based on the `ignoreCritical` flag.
func (context *SeqNoEntryParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*SeqNoEntry, error) {

	var handled_BootstrapTime bool = false
	var handled_SeqNo bool = false

	progress := -1
	_ = progress

	value := &SeqNoEntry{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 212:
				if true {
					handled = true
					handled_BootstrapTime = true
					value.BootstrapTime = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.BootstrapTime = uint64(value.BootstrapTime<<8) | uint64(x)
						}
					}
				}
			case 214:
				if true {
					handled = true
					handled_SeqNo = true
					value.SeqNo = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.SeqNo = uint64(value.SeqNo<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_BootstrapTime && err == nil {
		err = enc.ErrSkipRequired{Name: "BootstrapTime", TypeNum: 212}
	}
	if !handled_SeqNo && err == nil {
		err = enc.ErrSkipRequired{Name: "SeqNo", TypeNum: 214}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the sequence number entry into a wire format using the associated encoder.
func (value *SeqNoEntry) Encode() enc.Wire {
	encoder := SeqNoEntryEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// **Function Description:**  
Returns the encoded sequence number entry as a concatenated byte slice for serialization.  

**Explanation:**  
This function encodes the `SeqNoEntry` value (likely into a structured or segmented byte format) and joins the resulting components into a single contiguous byte slice, enabling efficient transmission or storage.
func (value *SeqNoEntry) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a TLV-encoded sequence number entry from the provided wire format into a SeqNoEntry structure, with an option to ignore critical unrecognized elements.
func ParseSeqNoEntry(reader enc.WireView, ignoreCritical bool) (*SeqNoEntry, error) {
	context := SeqNoEntryParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type PassiveStateEncoder struct {
	Length uint

	wirePlan []uint

	Data_subencoder []struct {
	}
}

type PassiveStateParsingContext struct {
}

// Initializes the PassiveStateEncoder with the provided PassiveState data, calculates the total encoded length required for the data array, and prepares a wire encoding plan for TLV-based serialization.
func (encoder *PassiveStateEncoder) Init(value *PassiveState) {
	{
		Data_l := len(value.Data)
		encoder.Data_subencoder = make([]struct {
		}, Data_l)
		for i := 0; i < Data_l; i++ {
			pseudoEncoder := &encoder.Data_subencoder[i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: value.Data[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Data != nil {
		for seq_i, seq_v := range value.Data {
			pseudoEncoder := &encoder.Data_subencoder[seq_i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Data != nil {
					l += 3
					l += uint(enc.TLNum(len(value.Data)).EncodingLength())
					l += uint(len(value.Data))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Data != nil {
		for seq_i, seq_v := range value.Data {
			pseudoEncoder := &encoder.Data_subencoder[seq_i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Data != nil {
					l += 3
					l += uint(enc.TLNum(len(value.Data)).EncodingLength())
					l += uint(len(value.Data))
				}
				_ = encoder
				_ = value
			}
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the PassiveStateParsingContext to its default state for parsing operations.
func (context *PassiveStateParsingContext) Init() {

}

// Encodes the Data field of a PassiveState into a TLV wire format using a subencoder, serializing each byte slice element with type 253 and a calculated length.
func (encoder *PassiveStateEncoder) EncodeInto(value *PassiveState, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.Data != nil {
		for seq_i, seq_v := range value.Data {
			pseudoEncoder := &encoder.Data_subencoder[seq_i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Data != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(4000))
					pos += 3
					pos += uint(enc.TLNum(len(value.Data)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Data)
					pos += uint(len(value.Data))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a PassiveState into a wire format by allocating a byte buffer according to the encoder's predefined wire plan and populating it with the state's data.
func (encoder *PassiveStateEncoder) Encode(value *PassiveState) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses binary-encoded PassiveState data from a WireView reader, handling the 'Data' field (type 4000) and skipping or rejecting unknown critical fields based on the ignoreCritical flag.
func (context *PassiveStateParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*PassiveState, error) {

	var handled_Data bool = false

	progress := -1
	_ = progress

	value := &PassiveState{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 4000:
				if true {
					handled = true
					handled_Data = true
					if value.Data == nil {
						value.Data = make([][]byte, 0)
					}
					{
						pseudoValue := struct {
							Data []byte
						}{}
						{
							value := &pseudoValue
							value.Data = make([]byte, l)
							_, err = reader.ReadFull(value.Data)
							_ = value
						}
						value.Data = append(value.Data, pseudoValue.Data)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Data && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the PassiveState object into a wire format using the PassiveStateEncoder for transmission or storage.
func (value *PassiveState) Encode() enc.Wire {
	encoder := PassiveStateEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Serializes the PassiveState value into a byte slice by encoding its components and concatenating them.
func (value *PassiveState) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a PassiveState object from the provided wire format data, with an option to skip critical fields if the ignoreCritical flag is enabled.
func ParsePassiveState(reader enc.WireView, ignoreCritical bool) (*PassiveState, error) {
	context := PassiveStateParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
