package trust_schema_test

import (
	"testing"

	enc "github.com/named-data/ndnd/std/encoding"
	"github.com/named-data/ndnd/std/security/trust_schema"
	tu "github.com/named-data/ndnd/std/utils/testutils"
	"github.com/stretchr/testify/require"
)

/*
#site: "a"/"blog"
#root: #site/#KEY
#article: #site/"article"/category/year/month <= #author
#author: #site/role/author/#KEY & { role: "author" } <= #admin
#admin: #site/"admin"/admin/#KEY <= #root
#KEY: "KEY"/_/_/_
*/
var TEST_MODEL = []byte{
	0x61, 0x04, 0x00, 0x01, 0x10, 0x00, 0x25, 0x01, 0x00, 0x69, 0x01, 0x06,
	0x63, 0x19, 0x25, 0x01, 0x00, 0x51, 0x08, 0x25, 0x01, 0x01, 0x21, 0x03,
	0x08, 0x01, 0x61, 0x51, 0x0a, 0x25, 0x01, 0x17, 0x21, 0x05, 0x08, 0x03,
	0x4b, 0x45, 0x59, 0x63, 0x13, 0x25, 0x01, 0x01, 0x57, 0x01, 0x00, 0x51,
	0x0b, 0x25, 0x01, 0x02, 0x21, 0x06, 0x08, 0x04, 0x62, 0x6c, 0x6f, 0x67,
	0x63, 0x4d, 0x25, 0x01, 0x02, 0x57, 0x01, 0x01, 0x29, 0x05, 0x23, 0x73,
	0x69, 0x74, 0x65, 0x51, 0x0a, 0x25, 0x01, 0x03, 0x21, 0x05, 0x08, 0x03,
	0x4b, 0x45, 0x59, 0x51, 0x0c, 0x25, 0x01, 0x07, 0x21, 0x07, 0x08, 0x05,
	0x61, 0x64, 0x6d, 0x69, 0x6e, 0x51, 0x0e, 0x25, 0x01, 0x0d, 0x21, 0x09,
	0x08, 0x07, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x53, 0x14, 0x25,
	0x01, 0x11, 0x23, 0x01, 0x01, 0x43, 0x0c, 0x41, 0x0a, 0x21, 0x08, 0x08,
	0x06, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x0e, 0x25, 0x01, 0x03,
	0x57, 0x01, 0x02, 0x53, 0x06, 0x25, 0x01, 0x04, 0x23, 0x01, 0x07, 0x63,
	0x0e, 0x25, 0x01, 0x04, 0x57, 0x01, 0x03, 0x53, 0x06, 0x25, 0x01, 0x05,
	0x23, 0x01, 0x08, 0x63, 0x0e, 0x25, 0x01, 0x05, 0x57, 0x01, 0x04, 0x53,
	0x06, 0x25, 0x01, 0x06, 0x23, 0x01, 0x09, 0x63, 0x0d, 0x25, 0x01, 0x06,
	0x57, 0x01, 0x05, 0x29, 0x05, 0x23, 0x72, 0x6f, 0x6f, 0x74, 0x63, 0x0e,
	0x25, 0x01, 0x07, 0x57, 0x01, 0x02, 0x53, 0x06, 0x25, 0x01, 0x08, 0x23,
	0x01, 0x06, 0x63, 0x12, 0x25, 0x01, 0x08, 0x57, 0x01, 0x07, 0x51, 0x0a,
	0x25, 0x01, 0x09, 0x21, 0x05, 0x08, 0x03, 0x4b, 0x45, 0x59, 0x63, 0x0e,
	0x25, 0x01, 0x09, 0x57, 0x01, 0x08, 0x53, 0x06, 0x25, 0x01, 0x0a, 0x23,
	0x01, 0x0a, 0x63, 0x0e, 0x25, 0x01, 0x0a, 0x57, 0x01, 0x09, 0x53, 0x06,
	0x25, 0x01, 0x0b, 0x23, 0x01, 0x0b, 0x63, 0x0e, 0x25, 0x01, 0x0b, 0x57,
	0x01, 0x0a, 0x53, 0x06, 0x25, 0x01, 0x0c, 0x23, 0x01, 0x0c, 0x63, 0x11,
	0x25, 0x01, 0x0c, 0x57, 0x01, 0x0b, 0x29, 0x06, 0x23, 0x61, 0x64, 0x6d,
	0x69, 0x6e, 0x55, 0x01, 0x06, 0x63, 0x0e, 0x25, 0x01, 0x0d, 0x57, 0x01,
	0x02, 0x53, 0x06, 0x25, 0x01, 0x0e, 0x23, 0x01, 0x03, 0x63, 0x0e, 0x25,
	0x01, 0x0e, 0x57, 0x01, 0x0d, 0x53, 0x06, 0x25, 0x01, 0x0f, 0x23, 0x01,
	0x04, 0x63, 0x0e, 0x25, 0x01, 0x0f, 0x57, 0x01, 0x0e, 0x53, 0x06, 0x25,
	0x01, 0x10, 0x23, 0x01, 0x05, 0x63, 0x13, 0x25, 0x01, 0x10, 0x57, 0x01,
	0x0f, 0x29, 0x08, 0x23, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x55,
	0x01, 0x16, 0x63, 0x0e, 0x25, 0x01, 0x11, 0x57, 0x01, 0x02, 0x53, 0x06,
	0x25, 0x01, 0x12, 0x23, 0x01, 0x02, 0x63, 0x12, 0x25, 0x01, 0x12, 0x57,
	0x01, 0x11, 0x51, 0x0a, 0x25, 0x01, 0x13, 0x21, 0x05, 0x08, 0x03, 0x4b,
	0x45, 0x59, 0x63, 0x0e, 0x25, 0x01, 0x13, 0x57, 0x01, 0x12, 0x53, 0x06,
	0x25, 0x01, 0x14, 0x23, 0x01, 0x0d, 0x63, 0x0e, 0x25, 0x01, 0x14, 0x57,
	0x01, 0x13, 0x53, 0x06, 0x25, 0x01, 0x15, 0x23, 0x01, 0x0e, 0x63, 0x0e,
	0x25, 0x01, 0x15, 0x57, 0x01, 0x14, 0x53, 0x06, 0x25, 0x01, 0x16, 0x23,
	0x01, 0x0f, 0x63, 0x12, 0x25, 0x01, 0x16, 0x57, 0x01, 0x15, 0x29, 0x07,
	0x23, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x55, 0x01, 0x0c, 0x63, 0x0e,
	0x25, 0x01, 0x17, 0x57, 0x01, 0x00, 0x53, 0x06, 0x25, 0x01, 0x18, 0x23,
	0x01, 0x10, 0x63, 0x0e, 0x25, 0x01, 0x18, 0x57, 0x01, 0x17, 0x53, 0x06,
	0x25, 0x01, 0x19, 0x23, 0x01, 0x11, 0x63, 0x0e, 0x25, 0x01, 0x19, 0x57,
	0x01, 0x18, 0x53, 0x06, 0x25, 0x01, 0x1a, 0x23, 0x01, 0x12, 0x63, 0x0c,
	0x25, 0x01, 0x1a, 0x57, 0x01, 0x19, 0x29, 0x04, 0x23, 0x4b, 0x45, 0x59,
	0x67, 0x09, 0x23, 0x01, 0x01, 0x29, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x67,
	0x0b, 0x23, 0x01, 0x02, 0x29, 0x06, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72,
	0x67, 0x0d, 0x23, 0x01, 0x03, 0x29, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67,
	0x6f, 0x72, 0x79, 0x67, 0x09, 0x23, 0x01, 0x04, 0x29, 0x04, 0x79, 0x65,
	0x61, 0x72, 0x67, 0x0a, 0x23, 0x01, 0x05, 0x29, 0x05, 0x6d, 0x6f, 0x6e,
	0x74, 0x68, 0x67, 0x0a, 0x23, 0x01, 0x06, 0x29, 0x05, 0x61, 0x64, 0x6d,
	0x69, 0x6e,
}

/*
#r1: a/b/c & { c: b, c: a, a: "a"|"x" } | { b: "b"|"y" } <= #r2 | #r3
#r2: x/y/z & { x: "xxx" }
#r3: x/y/z & { y: "yyy" }
*/
var TEST_MODEL_COMPLEX = []byte{
	0x61, 0x04, 0x00, 0x01, 0x10, 0x00, 0x25, 0x01, 0x00, 0x69, 0x01, 0x06,
	0x63, 0x3e, 0x25, 0x01, 0x00, 0x53, 0x06, 0x25, 0x01, 0x01, 0x23, 0x01,
	0x01, 0x53, 0x11, 0x25, 0x01, 0x04, 0x23, 0x01, 0x01, 0x43, 0x09, 0x41,
	0x07, 0x21, 0x05, 0x08, 0x03, 0x78, 0x78, 0x78, 0x53, 0x06, 0x25, 0x01,
	0x07, 0x23, 0x01, 0x04, 0x53, 0x16, 0x25, 0x01, 0x0a, 0x23, 0x01, 0x04,
	0x43, 0x0e, 0x41, 0x05, 0x21, 0x03, 0x08, 0x01, 0x61, 0x41, 0x05, 0x21,
	0x03, 0x08, 0x01, 0x78, 0x63, 0x19, 0x25, 0x01, 0x01, 0x57, 0x01, 0x00,
	0x53, 0x11, 0x25, 0x01, 0x02, 0x23, 0x01, 0x02, 0x43, 0x09, 0x41, 0x07,
	0x21, 0x05, 0x08, 0x03, 0x79, 0x79, 0x79, 0x63, 0x0e, 0x25, 0x01, 0x02,
	0x57, 0x01, 0x01, 0x53, 0x06, 0x25, 0x01, 0x03, 0x23, 0x01, 0x03, 0x63,
	0x0b, 0x25, 0x01, 0x03, 0x57, 0x01, 0x02, 0x29, 0x03, 0x23, 0x72, 0x33,
	0x63, 0x0e, 0x25, 0x01, 0x04, 0x57, 0x01, 0x00, 0x53, 0x06, 0x25, 0x01,
	0x05, 0x23, 0x01, 0x02, 0x63, 0x0e, 0x25, 0x01, 0x05, 0x57, 0x01, 0x04,
	0x53, 0x06, 0x25, 0x01, 0x06, 0x23, 0x01, 0x03, 0x63, 0x0b, 0x25, 0x01,
	0x06, 0x57, 0x01, 0x05, 0x29, 0x03, 0x23, 0x72, 0x32, 0x63, 0x1e, 0x25,
	0x01, 0x07, 0x57, 0x01, 0x00, 0x53, 0x16, 0x25, 0x01, 0x08, 0x23, 0x01,
	0x05, 0x43, 0x0e, 0x41, 0x05, 0x21, 0x03, 0x08, 0x01, 0x62, 0x41, 0x05,
	0x21, 0x03, 0x08, 0x01, 0x79, 0x63, 0x0e, 0x25, 0x01, 0x08, 0x57, 0x01,
	0x07, 0x53, 0x06, 0x25, 0x01, 0x09, 0x23, 0x01, 0x06, 0x63, 0x11, 0x25,
	0x01, 0x09, 0x57, 0x01, 0x08, 0x29, 0x03, 0x23, 0x72, 0x31, 0x55, 0x01,
	0x03, 0x55, 0x01, 0x06, 0x63, 0x0e, 0x25, 0x01, 0x0a, 0x57, 0x01, 0x00,
	0x53, 0x06, 0x25, 0x01, 0x0b, 0x23, 0x01, 0x05, 0x63, 0x1c, 0x25, 0x01,
	0x0b, 0x57, 0x01, 0x0a, 0x53, 0x14, 0x25, 0x01, 0x0c, 0x23, 0x01, 0x06,
	0x43, 0x05, 0x41, 0x03, 0x23, 0x01, 0x05, 0x43, 0x05, 0x41, 0x03, 0x23,
	0x01, 0x04, 0x63, 0x11, 0x25, 0x01, 0x0c, 0x57, 0x01, 0x0b, 0x29, 0x03,
	0x23, 0x72, 0x31, 0x55, 0x01, 0x03, 0x55, 0x01, 0x06, 0x67, 0x06, 0x23,
	0x01, 0x01, 0x29, 0x01, 0x78, 0x67, 0x06, 0x23, 0x01, 0x02, 0x29, 0x01,
	0x79, 0x67, 0x06, 0x23, 0x01, 0x03, 0x29, 0x01, 0x7a, 0x67, 0x06, 0x23,
	0x01, 0x04, 0x29, 0x01, 0x61, 0x67, 0x06, 0x23, 0x01, 0x05, 0x29, 0x01,
	0x62, 0x67, 0x06, 0x23, 0x01, 0x06, 0x29, 0x01, 0x63,
}

// **Description:**  
Converts a string to an `enc.Name` by parsing it, assuming no errors occur during conversion.
func sname(n string) enc.Name {
	return tu.NoErr(enc.NameFromStr(n))
}

// Parses a trust schema model from a binary buffer and verifies its structural properties, including version, node count, symbol count, and pattern counts.
func TestParseModel(t *testing.T) {
	tu.SetT(t)

	m, err := trust_schema.ParseLvsModel(enc.NewBufferView(TEST_MODEL), false)
	require.NoError(t, err)

	require.Equal(t, uint64(0x00011000), m.Version)
	require.Equal(t, uint64(0), m.StartId)
	require.Equal(t, uint64(6), m.NamedPatternCnt)

	require.Equal(t, 27, len(m.Nodes))
	require.Equal(t, 6, len(m.Symbols))
}

// Tests the schema's ability to correctly match and collect rules for various name patterns, validating both successful matches against expected rules and failure cases for invalid or partial matches.
func TestModelSimpleMatch(t *testing.T) {
	tu.SetT(t)

	s, err := trust_schema.NewLvsSchema(TEST_MODEL)
	require.NoError(t, err)

	// Test all valid matches
	ms := s.MatchCollect(sname("/a/blog"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#site", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/a/blog/KEY/123/issuer/456"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#root", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/a/blog/article/category/year/month"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#article", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/a/blog/author/PANDA/KEY/kid/iss/v=1"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#author", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/a/blog/admin/PANDA/KEY/kid/iss/v=1"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#admin", string(ms[0].RuleName[0]))

	// Test invalid matches
	ms = s.MatchCollect(sname("/b/blog"))
	require.Equal(t, 0, len(ms))

	ms = s.MatchCollect(sname("/b/blog/KEY/123/issuer/456"))
	require.Equal(t, 0, len(ms))

	// Test partial matches
	ms = s.MatchCollect(sname("/a/blog/article/category/year/month/extra"))
	require.Equal(t, 0, len(ms))

	ms = s.MatchCollect(sname("/a/blog/article/category/year"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, 0, len(ms[0].RuleName)) // no matching rule

	// Test invalid expansion value
	ms = s.MatchCollect(sname("/a/blog/evil/PANDA/KEY/kid/iss/v=1"))
	require.Equal(t, 0, len(ms))
}

// Constructs a complex trust schema and verifies that the `MatchCollect` method correctly identifies applicable rules for various NDN names based on nested patterns and conditional constraints.
func TestModelComplexMatch(t *testing.T) {
	tu.SetT(t)

	s, err := trust_schema.NewLvsSchema(TEST_MODEL_COMPLEX)
	require.NoError(t, err)

	// #r1: a/b/c & { c: b, c: a, a: "a"|"x" }
	ms := s.MatchCollect(sname("/a/a/a"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#r1", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/x/x/x"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#r1", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/a/a/x"))
	require.Equal(t, 0, len(ms))

	ms = s.MatchCollect(sname("/a/c/a"))
	require.Equal(t, 0, len(ms))

	ms = s.MatchCollect(sname("/a/x/x"))
	require.Equal(t, 0, len(ms))

	// #r1: a/b/c & { b: "b"|"y" }
	ms = s.MatchCollect(sname("/a/b/c"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#r1", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/p/y/q"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#r1", string(ms[0].RuleName[0]))

	// #r2: x/y/z & { x: "xxx" }
	// #r3: x/y/z & { y: "yyy" }
	ms = s.MatchCollect(sname("/xxx/xxx/zzz"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#r2", string(ms[0].RuleName[0]))

	ms = s.MatchCollect(sname("/abc/yyy/zzz"))
	require.Equal(t, 1, len(ms))
	require.Equal(t, "#r3", string(ms[0].RuleName[0]))

	// Combination
	ms = s.MatchCollect(sname("/xxx/b/zzz"))
	require.Equal(t, 2, len(ms)) // r1, r2

	ms = s.MatchCollect(sname("/xxx/yyy/zzz"))
	require.Equal(t, 2, len(ms)) // r1, r3
}

// This function tests the access control logic of a trust schema by verifying whether specific hierarchical name relationships are correctly authorized or denied based on predefined schema rules.
func TestModelSimpleCheck(t *testing.T) {
	tu.SetT(t)

	s, err := trust_schema.NewLvsSchema(TEST_MODEL)
	require.NoError(t, err)

	require.True(t, s.Check(sname("/a/blog/admin/000001/KEY/1/root/1"), sname("/a/blog/KEY/1/self/1")))
	require.False(t, s.Check(sname("/a/blog/admin/000001/VAL/1/root/1"), sname("/a/blog/KEY/1/self/1")))
	require.False(t, s.Check(sname("/a/blog/admin/000002/KEY/1/root/1"), sname("/a/blog/admin/000001/KEY/1/root/1")))
	require.True(t, s.Check(sname("/a/blog/author/100001/KEY/1/000001/1"), sname("/a/blog/admin/000001/KEY/1/root/1")))
	require.False(t, s.Check(sname("/a/blog/author/100001/KEY/1/000001/1"), sname("/a/blog/KEY/1/self/1")))
}

// Validates the correctness of name-checking logic against a complex schema model by asserting allowed/denied name matches.
func TestModelComplexCheck(t *testing.T) {
	tu.SetT(t)

	s, err := trust_schema.NewLvsSchema(TEST_MODEL_COMPLEX)
	require.NoError(t, err)

	require.True(t, s.Check(sname("/a/b/c"), sname("/xxx/yyy/zzz")))
	require.True(t, s.Check(sname("/x/y/z"), sname("/xxx/xxx/xxx")))
	require.True(t, s.Check(sname("/x/x/x"), sname("/xxx/yyy/zzz")))
	require.True(t, s.Check(sname("/a/a/a"), sname("/xxx/xxx/xxx")))
	require.True(t, s.Check(sname("/a/b/c"), sname("/xxx/pqr/rst")))

	require.False(t, s.Check(sname("/xxx/yyy/zzz"), sname("/xxx/yyy/xxx")))
	require.False(t, s.Check(sname("/xxx/yyy/zzz"), sname("/a/b/c")))
	require.False(t, s.Check(sname("/a/b/c"), sname("/pqr/pqr/xxx")))
	require.False(t, s.Check(sname("/a/b/c"), sname("/xxx/pqr")))
	require.False(t, s.Check(sname("/a/b/c"), sname("/xxx/pqr/rst/uvw")))
}
