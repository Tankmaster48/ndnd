// Code generated by ndn tlv codegen DO NOT EDIT.
package trust_schema

import (
	"encoding/binary"
	"io"

	enc "github.com/named-data/ndnd/std/encoding"
	"github.com/named-data/ndnd/std/ndn/spec_2022"
)

type CrossSchemaContentEncoder struct {
	Length uint

	SimpleSchemaRules_subencoder []struct {
		SimpleSchemaRules_encoder SimpleSchemaRuleEncoder
	}
	PrefixSchemaRules_subencoder []struct {
		PrefixSchemaRules_encoder PrefixSchemaRuleEncoder
	}
}

type CrossSchemaContentParsingContext struct {
	SimpleSchemaRules_context SimpleSchemaRuleParsingContext
	PrefixSchemaRules_context PrefixSchemaRuleParsingContext
}

// Initializes the CrossSchemaContentEncoder with the provided schema rules, setting up sub-encoders for each rule and calculating the total encoded length based on TLV (Type-Length-Value) encoding requirements.
func (encoder *CrossSchemaContentEncoder) Init(value *CrossSchemaContent) {
	{
		SimpleSchemaRules_l := len(value.SimpleSchemaRules)
		encoder.SimpleSchemaRules_subencoder = make([]struct {
			SimpleSchemaRules_encoder SimpleSchemaRuleEncoder
		}, SimpleSchemaRules_l)
		for i := 0; i < SimpleSchemaRules_l; i++ {
			pseudoEncoder := &encoder.SimpleSchemaRules_subencoder[i]
			pseudoValue := struct {
				SimpleSchemaRules *SimpleSchemaRule
			}{
				SimpleSchemaRules: value.SimpleSchemaRules[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SimpleSchemaRules != nil {
					encoder.SimpleSchemaRules_encoder.Init(value.SimpleSchemaRules)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		PrefixSchemaRules_l := len(value.PrefixSchemaRules)
		encoder.PrefixSchemaRules_subencoder = make([]struct {
			PrefixSchemaRules_encoder PrefixSchemaRuleEncoder
		}, PrefixSchemaRules_l)
		for i := 0; i < PrefixSchemaRules_l; i++ {
			pseudoEncoder := &encoder.PrefixSchemaRules_subencoder[i]
			pseudoValue := struct {
				PrefixSchemaRules *PrefixSchemaRule
			}{
				PrefixSchemaRules: value.PrefixSchemaRules[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixSchemaRules != nil {
					encoder.PrefixSchemaRules_encoder.Init(value.PrefixSchemaRules)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.SimpleSchemaRules != nil {
		for seq_i, seq_v := range value.SimpleSchemaRules {
			pseudoEncoder := &encoder.SimpleSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				SimpleSchemaRules *SimpleSchemaRule
			}{
				SimpleSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SimpleSchemaRules != nil {
					l += 3
					l += uint(enc.TLNum(encoder.SimpleSchemaRules_encoder.Length).EncodingLength())
					l += encoder.SimpleSchemaRules_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PrefixSchemaRules != nil {
		for seq_i, seq_v := range value.PrefixSchemaRules {
			pseudoEncoder := &encoder.PrefixSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				PrefixSchemaRules *PrefixSchemaRule
			}{
				PrefixSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixSchemaRules != nil {
					l += 3
					l += uint(enc.TLNum(encoder.PrefixSchemaRules_encoder.Length).EncodingLength())
					l += encoder.PrefixSchemaRules_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the CrossSchemaContentParsingContext by initializing its associated SimpleSchemaRules and PrefixSchemaRules contexts.
func (context *CrossSchemaContentParsingContext) Init() {
	context.SimpleSchemaRules_context.Init()
	context.PrefixSchemaRules_context.Init()
}

// Encodes a CrossSchemaContent object into a binary TLV (Type-Length-Value) format in the provided buffer, serializing sequences of SimpleSchemaRules and PrefixSchemaRules using their respective sub-encoders with type identifiers 620 and 622.
func (encoder *CrossSchemaContentEncoder) EncodeInto(value *CrossSchemaContent, buf []byte) {

	pos := uint(0)

	if value.SimpleSchemaRules != nil {
		for seq_i, seq_v := range value.SimpleSchemaRules {
			pseudoEncoder := &encoder.SimpleSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				SimpleSchemaRules *SimpleSchemaRule
			}{
				SimpleSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SimpleSchemaRules != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(620))
					pos += 3
					pos += uint(enc.TLNum(encoder.SimpleSchemaRules_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.SimpleSchemaRules_encoder.Length > 0 {
						encoder.SimpleSchemaRules_encoder.EncodeInto(value.SimpleSchemaRules, buf[pos:])
						pos += encoder.SimpleSchemaRules_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PrefixSchemaRules != nil {
		for seq_i, seq_v := range value.PrefixSchemaRules {
			pseudoEncoder := &encoder.PrefixSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				PrefixSchemaRules *PrefixSchemaRule
			}{
				PrefixSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixSchemaRules != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(622))
					pos += 3
					pos += uint(enc.TLNum(encoder.PrefixSchemaRules_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.PrefixSchemaRules_encoder.Length > 0 {
						encoder.PrefixSchemaRules_encoder.EncodeInto(value.PrefixSchemaRules, buf[pos:])
						pos += encoder.PrefixSchemaRules_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the given CrossSchemaContent object into a binary wire format by allocating a buffer of the encoder's specified length and writing the encoded data into it.
func (encoder *CrossSchemaContentEncoder) Encode(value *CrossSchemaContent) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded Cross Schema content into a CrossSchemaContent object, handling SimpleSchemaRules (type 620) and PrefixSchemaRules (type 622) with delegated parsers, while enforcing critical field recognition unless ignoreCritical is true.
func (context *CrossSchemaContentParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*CrossSchemaContent, error) {

	var handled_SimpleSchemaRules bool = false
	var handled_PrefixSchemaRules bool = false

	progress := -1
	_ = progress

	value := &CrossSchemaContent{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 620:
				if true {
					handled = true
					handled_SimpleSchemaRules = true
					if value.SimpleSchemaRules == nil {
						value.SimpleSchemaRules = make([]*SimpleSchemaRule, 0)
					}
					{
						pseudoValue := struct {
							SimpleSchemaRules *SimpleSchemaRule
						}{}
						{
							value := &pseudoValue
							value.SimpleSchemaRules, err = context.SimpleSchemaRules_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.SimpleSchemaRules = append(value.SimpleSchemaRules, pseudoValue.SimpleSchemaRules)
					}
					progress--
				}
			case 622:
				if true {
					handled = true
					handled_PrefixSchemaRules = true
					if value.PrefixSchemaRules == nil {
						value.PrefixSchemaRules = make([]*PrefixSchemaRule, 0)
					}
					{
						pseudoValue := struct {
							PrefixSchemaRules *PrefixSchemaRule
						}{}
						{
							value := &pseudoValue
							value.PrefixSchemaRules, err = context.PrefixSchemaRules_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.PrefixSchemaRules = append(value.PrefixSchemaRules, pseudoValue.PrefixSchemaRules)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_SimpleSchemaRules && err == nil {
		// sequence - skip
	}
	if !handled_PrefixSchemaRules && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the CrossSchemaContent instance into its wire format representation using a CrossSchemaContentEncoder.
func (value *CrossSchemaContent) Encode() enc.Wire {
	encoder := CrossSchemaContentEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Joins the encoded components of CrossSchemaContent into a single byte slice.
func (value *CrossSchemaContent) Bytes() []byte {
	return value.Encode().Join()
}

// Parses encoded data into a CrossSchemaContent structure using a parsing context, with an option to ignore critical unrecognized elements.
func ParseCrossSchemaContent(reader enc.WireView, ignoreCritical bool) (*CrossSchemaContent, error) {
	context := CrossSchemaContentParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type SimpleSchemaRuleEncoder struct {
	Length uint

	NamePrefix_length  uint
	KeyLocator_encoder spec_2022.KeyLocatorEncoder
}

type SimpleSchemaRuleParsingContext struct {
	KeyLocator_context spec_2022.KeyLocatorParsingContext
}

// Initializes the encoder with the provided schema rule, calculating the total encoded length by summing the contributions of the name prefix components and key locator.
func (encoder *SimpleSchemaRuleEncoder) Init(value *SimpleSchemaRule) {
	if value.NamePrefix != nil {
		encoder.NamePrefix_length = 0
		for _, c := range value.NamePrefix {
			encoder.NamePrefix_length += uint(c.EncodingLength())
		}
	}
	if value.KeyLocator != nil {
		encoder.KeyLocator_encoder.Init(value.KeyLocator)
	}

	l := uint(0)
	if value.NamePrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NamePrefix_length).EncodingLength())
		l += encoder.NamePrefix_length
	}
	if value.KeyLocator != nil {
		l += 1
		l += uint(enc.TLNum(encoder.KeyLocator_encoder.Length).EncodingLength())
		l += encoder.KeyLocator_encoder.Length
	}
	encoder.Length = l

}

// Initializes the KeyLocator context embedded within the SimpleSchemaRuleParsingContext.
func (context *SimpleSchemaRuleParsingContext) Init() {

	context.KeyLocator_context.Init()
}

// Encodes a SimpleSchemaRule into a TLV (Type-Length-Value) binary format in the provided buffer, handling optional NamePrefix (type 7) and KeyLocator (type 28) fields with their respective sub-encoders.
func (encoder *SimpleSchemaRuleEncoder) EncodeInto(value *SimpleSchemaRule, buf []byte) {

	pos := uint(0)

	if value.NamePrefix != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NamePrefix_length).EncodeInto(buf[pos:]))
		for _, c := range value.NamePrefix {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.KeyLocator != nil {
		buf[pos] = byte(28)
		pos += 1
		pos += uint(enc.TLNum(encoder.KeyLocator_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.KeyLocator_encoder.Length > 0 {
			encoder.KeyLocator_encoder.EncodeInto(value.KeyLocator, buf[pos:])
			pos += encoder.KeyLocator_encoder.Length
		}
	}
}

// Encodes a SimpleSchemaRule into a binary wire format using the encoder's specified length, returning a slice containing the serialized byte array.
func (encoder *SimpleSchemaRuleEncoder) Encode(value *SimpleSchemaRule) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded SimpleSchemaRule from the provided WireView, handling NamePrefix (type 7) and KeyLocator (type 28) fields while skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *SimpleSchemaRuleParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*SimpleSchemaRule, error) {

	var handled_NamePrefix bool = false
	var handled_KeyLocator bool = false

	progress := -1
	_ = progress

	value := &SimpleSchemaRule{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NamePrefix = true
					delegate := reader.Delegate(int(l))
					value.NamePrefix, err = delegate.ReadName()
				}
			case 28:
				if true {
					handled = true
					handled_KeyLocator = true
					value.KeyLocator, err = context.KeyLocator_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NamePrefix && err == nil {
		value.NamePrefix = nil
	}
	if !handled_KeyLocator && err == nil {
		value.KeyLocator = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// "Encodes the SimpleSchemaRule into a binary wire format for network transmission or storage using the SimpleSchemaRuleEncoder."
func (value *SimpleSchemaRule) Encode() enc.Wire {
	encoder := SimpleSchemaRuleEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the schema rule by encoding its components and concatenating them.
func (value *SimpleSchemaRule) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a SimpleSchemaRule from encoded wire-format data using the provided WireView, with an option to ignore critical fields if specified.
func ParseSimpleSchemaRule(reader enc.WireView, ignoreCritical bool) (*SimpleSchemaRule, error) {
	context := SimpleSchemaRuleParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type PrefixSchemaRuleEncoder struct {
	Length uint

	NamePrefix_length uint
}

type PrefixSchemaRuleParsingContext struct {
}

// Initializes the encoder's total length based on the provided PrefixSchemaRule's name prefix, accounting for the encoded length of each prefix component and associated TLV (Type-Length-Value) overhead.
func (encoder *PrefixSchemaRuleEncoder) Init(value *PrefixSchemaRule) {
	if value.NamePrefix != nil {
		encoder.NamePrefix_length = 0
		for _, c := range value.NamePrefix {
			encoder.NamePrefix_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.NamePrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NamePrefix_length).EncodingLength())
		l += encoder.NamePrefix_length
	}
	encoder.Length = l

}

// Initializes the parsing context for prefix schema rules, preparing it to process and validate schema-based naming conventions in Named Data Networking.
func (context *PrefixSchemaRuleParsingContext) Init() {

}

// Encodes the NamePrefix field of a PrefixSchemaRule into a byte buffer using TLV (Type-Length-Value) format, writing the type byte 7, encoded length, and sequential name components if the NamePrefix is non-nil.
func (encoder *PrefixSchemaRuleEncoder) EncodeInto(value *PrefixSchemaRule, buf []byte) {

	pos := uint(0)

	if value.NamePrefix != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NamePrefix_length).EncodeInto(buf[pos:]))
		for _, c := range value.NamePrefix {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

// Encodes the provided PrefixSchemaRule into a byte slice according to the encoder's schema and returns it as a single-element enc.Wire array.
func (encoder *PrefixSchemaRuleEncoder) Encode(value *PrefixSchemaRule) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded PrefixSchemaRule, extracting the NamePrefix field (type 7) and handling unrecognized critical fields according to the ignoreCritical flag.
func (context *PrefixSchemaRuleParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*PrefixSchemaRule, error) {

	var handled_NamePrefix bool = false

	progress := -1
	_ = progress

	value := &PrefixSchemaRule{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NamePrefix = true
					delegate := reader.Delegate(int(l))
					value.NamePrefix, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NamePrefix && err == nil {
		value.NamePrefix = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the PrefixSchemaRule into its wire format representation using a PrefixSchemaRuleEncoder.
func (value *PrefixSchemaRule) Encode() enc.Wire {
	encoder := PrefixSchemaRuleEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the serialized byte representation of the PrefixSchemaRule by encoding its components and concatenating them.
func (value *PrefixSchemaRule) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a PrefixSchemaRule from wire-encoded data using a parsing context, with an option to ignore critical errors during decoding.
func ParsePrefixSchemaRule(reader enc.WireView, ignoreCritical bool) (*PrefixSchemaRule, error) {
	context := PrefixSchemaRuleParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsUserFnArgEncoder struct {
	Length uint
}

type LvsUserFnArgParsingContext struct {
}

// Calculates the total encoded length of an LvsUserFnArg by summing the size contributions of its Value and Tag fields for TLV (Type-Length-Value) encoding.
func (encoder *LvsUserFnArgEncoder) Init(value *LvsUserFnArg) {

	l := uint(0)
	if value.Value != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Value)).EncodingLength())
		l += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	encoder.Length = l

}

// Initializes the argument parsing context for use in processing user function arguments.
func (context *LvsUserFnArgParsingContext) Init() {

}

// Encodes the `LvsUserFnArg` value into a binary buffer, writing a `!` marker followed by the length-prefixed `Value` bytes if present, and a `#` marker followed by a length-prefixed natural number representation of the optional `Tag` if set.
func (encoder *LvsUserFnArgEncoder) EncodeInto(value *LvsUserFnArg, buf []byte) {

	pos := uint(0)

	if value.Value != nil {
		buf[pos] = byte(33)
		pos += 1
		pos += uint(enc.TLNum(len(value.Value)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Value)
		pos += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		buf[pos] = byte(35)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
}

// Encodes the provided LvsUserFnArg into a wire-format byte slice using the encoder's precomputed length and returns it as an enc.Wire containing a single byte slice element.
func (encoder *LvsUserFnArgEncoder) Encode(value *LvsUserFnArg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded LvsUserFnArg structure from a WireView reader, extracting a byte array value (type 33) and an integer tag (type 35), while handling critical fields according to the ignoreCritical flag.
func (context *LvsUserFnArgParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsUserFnArg, error) {

	var handled_Value bool = false
	var handled_Tag bool = false

	progress := -1
	_ = progress

	value := &LvsUserFnArg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 33:
				if true {
					handled = true
					handled_Value = true
					value.Value = make([]byte, l)
					_, err = reader.ReadFull(value.Value)
				}
			case 35:
				if true {
					handled = true
					handled_Tag = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Tag.Set(optval)
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Value && err == nil {
		value.Value = nil
	}
	if !handled_Tag && err == nil {
		value.Tag.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsUserFnArg value into a wire format for transmission.
func (value *LvsUserFnArg) Encode() enc.Wire {
	encoder := LvsUserFnArgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the encoded LvsUserFnArg value.
func (value *LvsUserFnArg) Bytes() []byte {
	return value.Encode().Join()
}

// Parses an LvsUserFnArg structure from encoded wire data, with an option to ignore critical unrecognized fields.
func ParseLvsUserFnArg(reader enc.WireView, ignoreCritical bool) (*LvsUserFnArg, error) {
	context := LvsUserFnArgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsUserFnCallEncoder struct {
	Length uint

	Args_subencoder []struct {
		Args_encoder LvsUserFnArgEncoder
	}
}

type LvsUserFnCallParsingContext struct {
	Args_context LvsUserFnArgParsingContext
}

// Initializes the encoder with the provided LvsUserFnCall value, calculating the total encoded length by summing the TLV-encoded sizes of the function ID and arguments.
func (encoder *LvsUserFnCallEncoder) Init(value *LvsUserFnCall) {

	{
		Args_l := len(value.Args)
		encoder.Args_subencoder = make([]struct {
			Args_encoder LvsUserFnArgEncoder
		}, Args_l)
		for i := 0; i < Args_l; i++ {
			pseudoEncoder := &encoder.Args_subencoder[i]
			pseudoValue := struct {
				Args *LvsUserFnArg
			}{
				Args: value.Args[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Args != nil {
					encoder.Args_encoder.Init(value.Args)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.FnId != nil {
		l += 1
		l += uint(enc.TLNum(len(value.FnId)).EncodingLength())
		l += uint(len(value.FnId))
	}
	if value.Args != nil {
		for seq_i, seq_v := range value.Args {
			pseudoEncoder := &encoder.Args_subencoder[seq_i]
			pseudoValue := struct {
				Args *LvsUserFnArg
			}{
				Args: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Args != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Args_encoder.Length).EncodingLength())
					l += encoder.Args_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the `LvsUserFnCallParsingContext` by initializing its embedded argument parsing context (`Args_context`).
func (context *LvsUserFnCallParsingContext) Init() {

	context.Args_context.Init()
}

// Encodes an LvsUserFnCall object into a binary buffer using type-length-value encoding, serializing the function ID (tag 39) and arguments (tag 51) with their respective encoders.
func (encoder *LvsUserFnCallEncoder) EncodeInto(value *LvsUserFnCall, buf []byte) {

	pos := uint(0)

	if value.FnId != nil {
		buf[pos] = byte(39)
		pos += 1
		pos += uint(enc.TLNum(len(value.FnId)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.FnId)
		pos += uint(len(value.FnId))
	}
	if value.Args != nil {
		for seq_i, seq_v := range value.Args {
			pseudoEncoder := &encoder.Args_subencoder[seq_i]
			pseudoValue := struct {
				Args *LvsUserFnArg
			}{
				Args: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Args != nil {
					buf[pos] = byte(51)
					pos += 1
					pos += uint(enc.TLNum(encoder.Args_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Args_encoder.Length > 0 {
						encoder.Args_encoder.EncodeInto(value.Args, buf[pos:])
						pos += encoder.Args_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the provided LvsUserFnCall value into a byte slice of length specified by the encoder, returning it as a single-element enc.Wire.
func (encoder *LvsUserFnCallEncoder) Encode(value *LvsUserFnCall) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded LvsUserFnCall structure from binary data, extracting a function identifier (FnId) and a sequence of arguments (Args) using the provided Args_context parser, with optional ignoreCritical handling for unknown fields.
func (context *LvsUserFnCallParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsUserFnCall, error) {

	var handled_FnId bool = false
	var handled_Args bool = false

	progress := -1
	_ = progress

	value := &LvsUserFnCall{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 39:
				if true {
					handled = true
					handled_FnId = true
					value.FnId = make([]byte, l)
					_, err = reader.ReadFull(value.FnId)
				}
			case 51:
				if true {
					handled = true
					handled_Args = true
					if value.Args == nil {
						value.Args = make([]*LvsUserFnArg, 0)
					}
					{
						pseudoValue := struct {
							Args *LvsUserFnArg
						}{}
						{
							value := &pseudoValue
							value.Args, err = context.Args_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Args = append(value.Args, pseudoValue.Args)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FnId && err == nil {
		value.FnId = nil
	}
	if !handled_Args && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsUserFnCall value into a wire format representation using an associated encoder.  

*Example rationale*: The function initializes an encoder with the provided value and then produces its encoded wire output, typical for NDN data structure serialization.
func (value *LvsUserFnCall) Encode() enc.Wire {
	encoder := LvsUserFnCallEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte slice representation of the LvsUserFnCall by encoding and joining its components.
func (value *LvsUserFnCall) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-format LvsUserFnCall structure into a typed object using the provided wire view and parsing context, with an option to ignore critical unrecognized components.
func ParseLvsUserFnCall(reader enc.WireView, ignoreCritical bool) (*LvsUserFnCall, error) {
	context := LvsUserFnCallParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsConstraintOptionEncoder struct {
	Length uint

	Fn_encoder LvsUserFnCallEncoder
}

type LvsConstraintOptionParsingContext struct {
	Fn_context LvsUserFnCallParsingContext
}

// Initializes the LvsConstraintOptionEncoder with the provided LvsConstraintOption, calculating the total encoded length by summing contributions from the Fn, Value, and Tag fields according to TLV encoding rules.
func (encoder *LvsConstraintOptionEncoder) Init(value *LvsConstraintOption) {

	if value.Fn != nil {
		encoder.Fn_encoder.Init(value.Fn)
	}

	l := uint(0)
	if value.Value != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Value)).EncodingLength())
		l += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Fn != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Fn_encoder.Length).EncodingLength())
		l += encoder.Fn_encoder.Length
	}
	encoder.Length = l

}

// Initializes the Fn_context component of the LvsConstraintOptionParsingContext.
func (context *LvsConstraintOptionParsingContext) Init() {

	context.Fn_context.Init()
}

// Encodes an LvsConstraintOption into a byte buffer using TLV (Type-Length-Value) format, handling optional fields (Value, Tag, Fn) with distinct type markers and recursively encoding nested structures.
func (encoder *LvsConstraintOptionEncoder) EncodeInto(value *LvsConstraintOption, buf []byte) {

	pos := uint(0)

	if value.Value != nil {
		buf[pos] = byte(33)
		pos += 1
		pos += uint(enc.TLNum(len(value.Value)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Value)
		pos += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		buf[pos] = byte(35)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Fn != nil {
		buf[pos] = byte(49)
		pos += 1
		pos += uint(enc.TLNum(encoder.Fn_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Fn_encoder.Length > 0 {
			encoder.Fn_encoder.EncodeInto(value.Fn, buf[pos:])
			pos += encoder.Fn_encoder.Length
		}
	}
}

// Encodes the provided LvsConstraintOption into a wire format by writing it into a byte slice of the encoder's specified length and returns the resulting wire structure.
func (encoder *LvsConstraintOptionEncoder) Encode(value *LvsConstraintOption) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded LvsConstraintOption from a WireView reader, handling Value (type 33), Tag (type 35), and Fn (type 49) fields while enforcing critical field constraints unless ignored.
func (context *LvsConstraintOptionParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsConstraintOption, error) {

	var handled_Value bool = false
	var handled_Tag bool = false
	var handled_Fn bool = false

	progress := -1
	_ = progress

	value := &LvsConstraintOption{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 33:
				if true {
					handled = true
					handled_Value = true
					value.Value = make([]byte, l)
					_, err = reader.ReadFull(value.Value)
				}
			case 35:
				if true {
					handled = true
					handled_Tag = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Tag.Set(optval)
					}
				}
			case 49:
				if true {
					handled = true
					handled_Fn = true
					value.Fn, err = context.Fn_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Value && err == nil {
		value.Value = nil
	}
	if !handled_Tag && err == nil {
		value.Tag.Unset()
	}
	if !handled_Fn && err == nil {
		value.Fn = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsConstraintOption into a wire format using the LvsConstraintOptionEncoder.
func (value *LvsConstraintOption) Encode() enc.Wire {
	encoder := LvsConstraintOptionEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the LVS constraint option by encoding its components and concatenating them into a single byte slice.
func (value *LvsConstraintOption) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded LVS constraint option into a structured object, optionally ignoring critical unrecognized constraints.
func ParseLvsConstraintOption(reader enc.WireView, ignoreCritical bool) (*LvsConstraintOption, error) {
	context := LvsConstraintOptionParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsPatternConstraintEncoder struct {
	Length uint

	ConsOptions_subencoder []struct {
		ConsOptions_encoder LvsConstraintOptionEncoder
	}
}

type LvsPatternConstraintParsingContext struct {
	ConsOptions_context LvsConstraintOptionParsingContext
}

// Initializes the encoder with the given LvsPatternConstraint, setting up subencoders for each constraint option and calculating the total encoded length including TLV overhead.
func (encoder *LvsPatternConstraintEncoder) Init(value *LvsPatternConstraint) {
	{
		ConsOptions_l := len(value.ConsOptions)
		encoder.ConsOptions_subencoder = make([]struct {
			ConsOptions_encoder LvsConstraintOptionEncoder
		}, ConsOptions_l)
		for i := 0; i < ConsOptions_l; i++ {
			pseudoEncoder := &encoder.ConsOptions_subencoder[i]
			pseudoValue := struct {
				ConsOptions *LvsConstraintOption
			}{
				ConsOptions: value.ConsOptions[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsOptions != nil {
					encoder.ConsOptions_encoder.Init(value.ConsOptions)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.ConsOptions != nil {
		for seq_i, seq_v := range value.ConsOptions {
			pseudoEncoder := &encoder.ConsOptions_subencoder[seq_i]
			pseudoValue := struct {
				ConsOptions *LvsConstraintOption
			}{
				ConsOptions: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsOptions != nil {
					l += 1
					l += uint(enc.TLNum(encoder.ConsOptions_encoder.Length).EncodingLength())
					l += encoder.ConsOptions_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the ConsOptions context within the LvsPatternConstraintParsingContext.
func (context *LvsPatternConstraintParsingContext) Init() {
	context.ConsOptions_context.Init()
}

// Encodes the `ConsOptions` sequence of an `LvsPatternConstraint` into a binary buffer using TLV (Type-Length-Value) encoding, with each constraint option processed by its dedicated subencoder.
func (encoder *LvsPatternConstraintEncoder) EncodeInto(value *LvsPatternConstraint, buf []byte) {

	pos := uint(0)

	if value.ConsOptions != nil {
		for seq_i, seq_v := range value.ConsOptions {
			pseudoEncoder := &encoder.ConsOptions_subencoder[seq_i]
			pseudoValue := struct {
				ConsOptions *LvsConstraintOption
			}{
				ConsOptions: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsOptions != nil {
					buf[pos] = byte(65)
					pos += 1
					pos += uint(enc.TLNum(encoder.ConsOptions_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.ConsOptions_encoder.Length > 0 {
						encoder.ConsOptions_encoder.EncodeInto(value.ConsOptions, buf[pos:])
						pos += encoder.ConsOptions_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes an LvsPatternConstraint into a binary wire format using the encoder's specified buffer length, returning the serialized data as a slice of byte slices.
func (encoder *LvsPatternConstraintEncoder) Encode(value *LvsPatternConstraint) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded LvsPatternConstraint from the provided wire format reader, handling ConsOptions fields and skipping unrecognized or non-critical fields based on the ignoreCritical flag.
func (context *LvsPatternConstraintParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsPatternConstraint, error) {

	var handled_ConsOptions bool = false

	progress := -1
	_ = progress

	value := &LvsPatternConstraint{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 65:
				if true {
					handled = true
					handled_ConsOptions = true
					if value.ConsOptions == nil {
						value.ConsOptions = make([]*LvsConstraintOption, 0)
					}
					{
						pseudoValue := struct {
							ConsOptions *LvsConstraintOption
						}{}
						{
							value := &pseudoValue
							value.ConsOptions, err = context.ConsOptions_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.ConsOptions = append(value.ConsOptions, pseudoValue.ConsOptions)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ConsOptions && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsPatternConstraint into a wire format using a dedicated encoder.
func (value *LvsPatternConstraint) Encode() enc.Wire {
	encoder := LvsPatternConstraintEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the concatenated byte representation of the encoded LvsPatternConstraint components.
func (value *LvsPatternConstraint) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a LVS pattern constraint from encoded data, using a parsing context and an option to ignore critical unrecognized components.
func ParseLvsPatternConstraint(reader enc.WireView, ignoreCritical bool) (*LvsPatternConstraint, error) {
	context := LvsPatternConstraintParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsPatternEdgeEncoder struct {
	Length uint

	ConsSets_subencoder []struct {
		ConsSets_encoder LvsPatternConstraintEncoder
	}
}

type LvsPatternEdgeParsingContext struct {
	ConsSets_context LvsPatternConstraintParsingContext
}

// Initializes the LvsPatternEdgeEncoder with the provided LvsPatternEdge value, setting up nested constraint encoders and calculating the total encoded length including TLV overhead for Dest, Tag, and ConsSets fields.
func (encoder *LvsPatternEdgeEncoder) Init(value *LvsPatternEdge) {

	{
		ConsSets_l := len(value.ConsSets)
		encoder.ConsSets_subencoder = make([]struct {
			ConsSets_encoder LvsPatternConstraintEncoder
		}, ConsSets_l)
		for i := 0; i < ConsSets_l; i++ {
			pseudoEncoder := &encoder.ConsSets_subencoder[i]
			pseudoValue := struct {
				ConsSets *LvsPatternConstraint
			}{
				ConsSets: value.ConsSets[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsSets != nil {
					encoder.ConsSets_encoder.Init(value.ConsSets)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Dest).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.Tag).EncodingLength())
	if value.ConsSets != nil {
		for seq_i, seq_v := range value.ConsSets {
			pseudoEncoder := &encoder.ConsSets_subencoder[seq_i]
			pseudoValue := struct {
				ConsSets *LvsPatternConstraint
			}{
				ConsSets: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsSets != nil {
					l += 1
					l += uint(enc.TLNum(encoder.ConsSets_encoder.Length).EncodingLength())
					l += encoder.ConsSets_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the `ConsSets_context` field of the `LvsPatternEdgeParsingContext`.
func (context *LvsPatternEdgeParsingContext) Init() {

	context.ConsSets_context.Init()
}

// Encodes an LvsPatternEdge data structure into a binary buffer using a TLV (Type-Length-Value) format, including fields for destination, tag, and optional constraint sets with type-specific encoding.
func (encoder *LvsPatternEdgeEncoder) EncodeInto(value *LvsPatternEdge, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Dest).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(35)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Tag).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.ConsSets != nil {
		for seq_i, seq_v := range value.ConsSets {
			pseudoEncoder := &encoder.ConsSets_subencoder[seq_i]
			pseudoValue := struct {
				ConsSets *LvsPatternConstraint
			}{
				ConsSets: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsSets != nil {
					buf[pos] = byte(67)
					pos += 1
					pos += uint(enc.TLNum(encoder.ConsSets_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.ConsSets_encoder.Length > 0 {
						encoder.ConsSets_encoder.EncodeInto(value.ConsSets, buf[pos:])
						pos += encoder.ConsSets_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes an LvsPatternEdge into a wire byte slice using the pre-determined length specified by the encoder.
func (encoder *LvsPatternEdgeEncoder) Encode(value *LvsPatternEdge) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded LvsPatternEdge structure into a Go object, handling required fields (Dest, Tag) and optional ConsSets constraints while validating critical fields according to NDN encoding rules.
func (context *LvsPatternEdgeParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsPatternEdge, error) {

	var handled_Dest bool = false
	var handled_Tag bool = false
	var handled_ConsSets bool = false

	progress := -1
	_ = progress

	value := &LvsPatternEdge{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 37:
				if true {
					handled = true
					handled_Dest = true
					value.Dest = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Dest = uint64(value.Dest<<8) | uint64(x)
						}
					}
				}
			case 35:
				if true {
					handled = true
					handled_Tag = true
					value.Tag = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Tag = uint64(value.Tag<<8) | uint64(x)
						}
					}
				}
			case 67:
				if true {
					handled = true
					handled_ConsSets = true
					if value.ConsSets == nil {
						value.ConsSets = make([]*LvsPatternConstraint, 0)
					}
					{
						pseudoValue := struct {
							ConsSets *LvsPatternConstraint
						}{}
						{
							value := &pseudoValue
							value.ConsSets, err = context.ConsSets_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.ConsSets = append(value.ConsSets, pseudoValue.ConsSets)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Dest && err == nil {
		err = enc.ErrSkipRequired{Name: "Dest", TypeNum: 37}
	}
	if !handled_Tag && err == nil {
		err = enc.ErrSkipRequired{Name: "Tag", TypeNum: 35}
	}
	if !handled_ConsSets && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsPatternEdge value into its wire representation using an LvsPatternEdgeEncoder.
func (value *LvsPatternEdge) Encode() enc.Wire {
	encoder := LvsPatternEdgeEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the LvsPatternEdge by encoding its components and concatenating them into a single byte slice.
func (value *LvsPatternEdge) Bytes() []byte {
	return value.Encode().Join()
}

// Parses an LvsPatternEdge structure from the provided wire view, initializing a parsing context and using the ignoreCritical flag to determine handling of critical TLV elements.
func ParseLvsPatternEdge(reader enc.WireView, ignoreCritical bool) (*LvsPatternEdge, error) {
	context := LvsPatternEdgeParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsValueEdgeEncoder struct {
	Length uint
}

type LvsValueEdgeParsingContext struct {
}

// Initializes the encoder's length by calculating the total encoded size of the LvsValueEdge, including 1 byte for the Dest field's type, its natural number encoding length, and conditional 1 byte plus encoded length and raw size for the optional Value field.
func (encoder *LvsValueEdgeEncoder) Init(value *LvsValueEdge) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Dest).EncodingLength())
	if value.Value != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Value)).EncodingLength())
		l += uint(len(value.Value))
	}
	encoder.Length = l

}

// Initializes the LvsValueEdgeParsingContext, but performs no actions.
func (context *LvsValueEdgeParsingContext) Init() {

}

// Encodes an LvsValueEdge into a binary buffer with a fixed header (37) for the destination, followed by a variable-length natural number encoding of the destination, and optionally includes a tagged (33) value payload with length prefixing.
func (encoder *LvsValueEdgeEncoder) EncodeInto(value *LvsValueEdge, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Dest).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Value != nil {
		buf[pos] = byte(33)
		pos += 1
		pos += uint(enc.TLNum(len(value.Value)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Value)
		pos += uint(len(value.Value))
	}
}

// Encodes the provided LvsValueEdge into a wire-format byte slice using the encoder's precomputed length and returns it as an enc.Wire.
func (encoder *LvsValueEdgeEncoder) Encode(value *LvsValueEdge) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded data into an `LvsValueEdge` struct containing a required `Dest` (uint64) and optional `Value` field, with optional skipping of critical fields when `ignoreCritical` is true.
func (context *LvsValueEdgeParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsValueEdge, error) {

	var handled_Dest bool = false
	var handled_Value bool = false

	progress := -1
	_ = progress

	value := &LvsValueEdge{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 37:
				if true {
					handled = true
					handled_Dest = true
					value.Dest = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Dest = uint64(value.Dest<<8) | uint64(x)
						}
					}
				}
			case 33:
				if true {
					handled = true
					handled_Value = true
					value.Value = make([]byte, l)
					_, err = reader.ReadFull(value.Value)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Dest && err == nil {
		err = enc.ErrSkipRequired{Name: "Dest", TypeNum: 37}
	}
	if !handled_Value && err == nil {
		value.Value = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsValueEdge value into a wire format representation using the LvsValueEdgeEncoder.
func (value *LvsValueEdge) Encode() enc.Wire {
	encoder := LvsValueEdgeEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded bytes of the LvsValueEdge by concatenating its encoded components.
func (value *LvsValueEdge) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a TLV-encoded LvsValueEdge structure from the provided wire view, with an option to ignore critical unrecognized elements.
func ParseLvsValueEdge(reader enc.WireView, ignoreCritical bool) (*LvsValueEdge, error) {
	context := LvsValueEdgeParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsNodeEncoder struct {
	Length uint

	RuleName_subencoder []struct {
	}
	Edges_subencoder []struct {
		Edges_encoder LvsValueEdgeEncoder
	}
	PatternEdges_subencoder []struct {
		PatternEdges_encoder LvsPatternEdgeEncoder
	}
	SignCons_subencoder []struct {
	}
}

type LvsNodeParsingContext struct {
	Edges_context        LvsValueEdgeParsingContext
	PatternEdges_context LvsPatternEdgeParsingContext
}

// Initializes the LvsNodeEncoder with the provided LvsNode value, configuring subencoders for its RuleName, Edges, PatternEdges, and SignCons fields while calculating the total encoded length for TLV-based serialization.
func (encoder *LvsNodeEncoder) Init(value *LvsNode) {

	{
		RuleName_l := len(value.RuleName)
		encoder.RuleName_subencoder = make([]struct {
		}, RuleName_l)
		for i := 0; i < RuleName_l; i++ {
			pseudoEncoder := &encoder.RuleName_subencoder[i]
			pseudoValue := struct {
				RuleName []byte
			}{
				RuleName: value.RuleName[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}
	{
		Edges_l := len(value.Edges)
		encoder.Edges_subencoder = make([]struct {
			Edges_encoder LvsValueEdgeEncoder
		}, Edges_l)
		for i := 0; i < Edges_l; i++ {
			pseudoEncoder := &encoder.Edges_subencoder[i]
			pseudoValue := struct {
				Edges *LvsValueEdge
			}{
				Edges: value.Edges[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Edges != nil {
					encoder.Edges_encoder.Init(value.Edges)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		PatternEdges_l := len(value.PatternEdges)
		encoder.PatternEdges_subencoder = make([]struct {
			PatternEdges_encoder LvsPatternEdgeEncoder
		}, PatternEdges_l)
		for i := 0; i < PatternEdges_l; i++ {
			pseudoEncoder := &encoder.PatternEdges_subencoder[i]
			pseudoValue := struct {
				PatternEdges *LvsPatternEdge
			}{
				PatternEdges: value.PatternEdges[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PatternEdges != nil {
					encoder.PatternEdges_encoder.Init(value.PatternEdges)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		SignCons_l := len(value.SignCons)
		encoder.SignCons_subencoder = make([]struct {
		}, SignCons_l)
		for i := 0; i < SignCons_l; i++ {
			pseudoEncoder := &encoder.SignCons_subencoder[i]
			pseudoValue := struct {
				SignCons uint64
			}{
				SignCons: value.SignCons[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Id).EncodingLength())
	if optval, ok := value.Parent.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.RuleName != nil {
		for seq_i, seq_v := range value.RuleName {
			pseudoEncoder := &encoder.RuleName_subencoder[seq_i]
			pseudoValue := struct {
				RuleName []byte
			}{
				RuleName: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.RuleName != nil {
					l += 1
					l += uint(enc.TLNum(len(value.RuleName)).EncodingLength())
					l += uint(len(value.RuleName))
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Edges != nil {
		for seq_i, seq_v := range value.Edges {
			pseudoEncoder := &encoder.Edges_subencoder[seq_i]
			pseudoValue := struct {
				Edges *LvsValueEdge
			}{
				Edges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Edges != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Edges_encoder.Length).EncodingLength())
					l += encoder.Edges_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PatternEdges != nil {
		for seq_i, seq_v := range value.PatternEdges {
			pseudoEncoder := &encoder.PatternEdges_subencoder[seq_i]
			pseudoValue := struct {
				PatternEdges *LvsPatternEdge
			}{
				PatternEdges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PatternEdges != nil {
					l += 1
					l += uint(enc.TLNum(encoder.PatternEdges_encoder.Length).EncodingLength())
					l += encoder.PatternEdges_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.SignCons != nil {
		for seq_i, seq_v := range value.SignCons {
			pseudoEncoder := &encoder.SignCons_subencoder[seq_i]
			pseudoValue := struct {
				SignCons uint64
			}{
				SignCons: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(1 + enc.Nat(value.SignCons).EncodingLength())
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the `Edges_context` and `PatternEdges_context` sub-contexts within the `LvsNodeParsingContext`.
func (context *LvsNodeParsingContext) Init() {

	context.Edges_context.Init()
	context.PatternEdges_context.Init()

}

// Encodes an LvsNode structure into a binary buffer using TLV (Type-Length-Value) encoding, serializing fields such as node ID (type 37), parent ID (type 87), rule names (type 41), edges (type 81), pattern edges (type 83), and signature constraints (type 85) with appropriate length prefixes and nested encodings.
func (encoder *LvsNodeEncoder) EncodeInto(value *LvsNode, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Id).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if optval, ok := value.Parent.Get(); ok {
		buf[pos] = byte(87)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.RuleName != nil {
		for seq_i, seq_v := range value.RuleName {
			pseudoEncoder := &encoder.RuleName_subencoder[seq_i]
			pseudoValue := struct {
				RuleName []byte
			}{
				RuleName: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.RuleName != nil {
					buf[pos] = byte(41)
					pos += 1
					pos += uint(enc.TLNum(len(value.RuleName)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.RuleName)
					pos += uint(len(value.RuleName))
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Edges != nil {
		for seq_i, seq_v := range value.Edges {
			pseudoEncoder := &encoder.Edges_subencoder[seq_i]
			pseudoValue := struct {
				Edges *LvsValueEdge
			}{
				Edges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Edges != nil {
					buf[pos] = byte(81)
					pos += 1
					pos += uint(enc.TLNum(encoder.Edges_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Edges_encoder.Length > 0 {
						encoder.Edges_encoder.EncodeInto(value.Edges, buf[pos:])
						pos += encoder.Edges_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PatternEdges != nil {
		for seq_i, seq_v := range value.PatternEdges {
			pseudoEncoder := &encoder.PatternEdges_subencoder[seq_i]
			pseudoValue := struct {
				PatternEdges *LvsPatternEdge
			}{
				PatternEdges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PatternEdges != nil {
					buf[pos] = byte(83)
					pos += 1
					pos += uint(enc.TLNum(encoder.PatternEdges_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.PatternEdges_encoder.Length > 0 {
						encoder.PatternEdges_encoder.EncodeInto(value.PatternEdges, buf[pos:])
						pos += encoder.PatternEdges_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.SignCons != nil {
		for seq_i, seq_v := range value.SignCons {
			pseudoEncoder := &encoder.SignCons_subencoder[seq_i]
			pseudoValue := struct {
				SignCons uint64
			}{
				SignCons: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(85)
				pos += 1

				buf[pos] = byte(enc.Nat(value.SignCons).EncodeInto(buf[pos+1:]))
				pos += uint(1 + buf[pos])
				_ = encoder
				_ = value
			}
		}
	}
}

// Serializes the provided `LvsNode` into a byte slice of length specified by the encoder and returns it as a `Wire` structure.
func (encoder *LvsNodeEncoder) Encode(value *LvsNode) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded wire format into an LvsNode structure, handling required fields like Id, optional fields like Parent, and nested elements such as Edges/PatternEdges using provided parsing contexts, with support for critical field skipping.
func (context *LvsNodeParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsNode, error) {

	var handled_Id bool = false
	var handled_Parent bool = false
	var handled_RuleName bool = false
	var handled_Edges bool = false
	var handled_PatternEdges bool = false
	var handled_SignCons bool = false

	progress := -1
	_ = progress

	value := &LvsNode{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 37:
				if true {
					handled = true
					handled_Id = true
					value.Id = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Id = uint64(value.Id<<8) | uint64(x)
						}
					}
				}
			case 87:
				if true {
					handled = true
					handled_Parent = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Parent.Set(optval)
					}
				}
			case 41:
				if true {
					handled = true
					handled_RuleName = true
					if value.RuleName == nil {
						value.RuleName = make([][]byte, 0)
					}
					{
						pseudoValue := struct {
							RuleName []byte
						}{}
						{
							value := &pseudoValue
							value.RuleName = make([]byte, l)
							_, err = reader.ReadFull(value.RuleName)
							_ = value
						}
						value.RuleName = append(value.RuleName, pseudoValue.RuleName)
					}
					progress--
				}
			case 81:
				if true {
					handled = true
					handled_Edges = true
					if value.Edges == nil {
						value.Edges = make([]*LvsValueEdge, 0)
					}
					{
						pseudoValue := struct {
							Edges *LvsValueEdge
						}{}
						{
							value := &pseudoValue
							value.Edges, err = context.Edges_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Edges = append(value.Edges, pseudoValue.Edges)
					}
					progress--
				}
			case 83:
				if true {
					handled = true
					handled_PatternEdges = true
					if value.PatternEdges == nil {
						value.PatternEdges = make([]*LvsPatternEdge, 0)
					}
					{
						pseudoValue := struct {
							PatternEdges *LvsPatternEdge
						}{}
						{
							value := &pseudoValue
							value.PatternEdges, err = context.PatternEdges_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.PatternEdges = append(value.PatternEdges, pseudoValue.PatternEdges)
					}
					progress--
				}
			case 85:
				if true {
					handled = true
					handled_SignCons = true
					if value.SignCons == nil {
						value.SignCons = make([]uint64, 0)
					}
					{
						pseudoValue := struct {
							SignCons uint64
						}{}
						{
							value := &pseudoValue
							value.SignCons = uint64(0)
							{
								for i := 0; i < int(l); i++ {
									x := byte(0)
									x, err = reader.ReadByte()
									if err != nil {
										if err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										break
									}
									value.SignCons = uint64(value.SignCons<<8) | uint64(x)
								}
							}
							_ = value
						}
						value.SignCons = append(value.SignCons, pseudoValue.SignCons)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Id && err == nil {
		err = enc.ErrSkipRequired{Name: "Id", TypeNum: 37}
	}
	if !handled_Parent && err == nil {
		value.Parent.Unset()
	}
	if !handled_RuleName && err == nil {
		// sequence - skip
	}
	if !handled_Edges && err == nil {
		// sequence - skip
	}
	if !handled_PatternEdges && err == nil {
		// sequence - skip
	}
	if !handled_SignCons && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsNode into a binary wire format using an LvsNodeEncoder for transmission or storage.
func (value *LvsNode) Encode() enc.Wire {
	encoder := LvsNodeEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the LvsNode by encoding its internal structure and concatenating the resulting components into a single byte slice.
func (value *LvsNode) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a TLV-encoded LvsNode structure from the provided WireView, optionally ignoring critical elements that cannot be processed if the ignoreCritical flag is enabled.
func ParseLvsNode(reader enc.WireView, ignoreCritical bool) (*LvsNode, error) {
	context := LvsNodeParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsTagSymbolEncoder struct {
	Length uint
}

type LvsTagSymbolParsingContext struct {
}

// Initializes the encoder's length by calculating the total encoded size of the LvsTagSymbol, accounting for optional Tag and Ident fields using TLV (Type-Length-Value) encoding rules.
func (encoder *LvsTagSymbolEncoder) Init(value *LvsTagSymbol) {

	l := uint(0)
	if optval, ok := value.Tag.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Ident != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Ident)).EncodingLength())
		l += uint(len(value.Ident))
	}
	encoder.Length = l

}

// Initializes the parsing context for LVS tag symbols, preparing it for subsequent parsing operations.
func (context *LvsTagSymbolParsingContext) Init() {

}

// Encodes an LvsTagSymbol into the provided byte buffer, writing the Tag value (if present) as a type-length-value field prefixed with '#' and the Ident field (if non-nil) as a type-length-value field prefixed with ')'.
func (encoder *LvsTagSymbolEncoder) EncodeInto(value *LvsTagSymbol, buf []byte) {

	pos := uint(0)

	if optval, ok := value.Tag.Get(); ok {
		buf[pos] = byte(35)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Ident != nil {
		buf[pos] = byte(41)
		pos += 1
		pos += uint(enc.TLNum(len(value.Ident)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Ident)
		pos += uint(len(value.Ident))
	}
}

// Constructs a wire-encoded byte slice for the given LvsTagSymbol using the encoder's specified length.
func (encoder *LvsTagSymbolEncoder) Encode(value *LvsTagSymbol) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded LvsTagSymbol from the provided wire format reader, handling 'Tag' (type 35) and 'Ident' (type 41) fields while skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *LvsTagSymbolParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsTagSymbol, error) {

	var handled_Tag bool = false
	var handled_Ident bool = false

	progress := -1
	_ = progress

	value := &LvsTagSymbol{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 35:
				if true {
					handled = true
					handled_Tag = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Tag.Set(optval)
					}
				}
			case 41:
				if true {
					handled = true
					handled_Ident = true
					value.Ident = make([]byte, l)
					_, err = reader.ReadFull(value.Ident)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Tag && err == nil {
		value.Tag.Unset()
	}
	if !handled_Ident && err == nil {
		value.Ident = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsTagSymbol value into a wire format using the LvsTagSymbolEncoder.
func (value *LvsTagSymbol) Encode() enc.Wire {
	encoder := LvsTagSymbolEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the LvsTagSymbol by encoding its components and concatenating them into a single byte slice.
func (value *LvsTagSymbol) Bytes() []byte {
	return value.Encode().Join()
}

// Parses an LvsTagSymbol from the provided wire data, optionally ignoring critical parsing errors.
func ParseLvsTagSymbol(reader enc.WireView, ignoreCritical bool) (*LvsTagSymbol, error) {
	context := LvsTagSymbolParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsModelEncoder struct {
	Length uint

	Nodes_subencoder []struct {
		Nodes_encoder LvsNodeEncoder
	}
	Symbols_subencoder []struct {
		Symbols_encoder LvsTagSymbolEncoder
	}
}

type LvsModelParsingContext struct {
	Nodes_context   LvsNodeParsingContext
	Symbols_context LvsTagSymbolParsingContext
}

// Initializes the LvsModelEncoder with the provided LvsModel value, setting up nested encoders for nodes and symbols and calculating the total encoded length required to serialize the model.
func (encoder *LvsModelEncoder) Init(value *LvsModel) {

	{
		Nodes_l := len(value.Nodes)
		encoder.Nodes_subencoder = make([]struct {
			Nodes_encoder LvsNodeEncoder
		}, Nodes_l)
		for i := 0; i < Nodes_l; i++ {
			pseudoEncoder := &encoder.Nodes_subencoder[i]
			pseudoValue := struct {
				Nodes *LvsNode
			}{
				Nodes: value.Nodes[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Nodes != nil {
					encoder.Nodes_encoder.Init(value.Nodes)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		Symbols_l := len(value.Symbols)
		encoder.Symbols_subencoder = make([]struct {
			Symbols_encoder LvsTagSymbolEncoder
		}, Symbols_l)
		for i := 0; i < Symbols_l; i++ {
			pseudoEncoder := &encoder.Symbols_subencoder[i]
			pseudoValue := struct {
				Symbols *LvsTagSymbol
			}{
				Symbols: value.Symbols[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Symbols != nil {
					encoder.Symbols_encoder.Init(value.Symbols)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Version).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.StartId).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.NamedPatternCnt).EncodingLength())
	if value.Nodes != nil {
		for seq_i, seq_v := range value.Nodes {
			pseudoEncoder := &encoder.Nodes_subencoder[seq_i]
			pseudoValue := struct {
				Nodes *LvsNode
			}{
				Nodes: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Nodes != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Nodes_encoder.Length).EncodingLength())
					l += encoder.Nodes_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Symbols != nil {
		for seq_i, seq_v := range value.Symbols {
			pseudoEncoder := &encoder.Symbols_subencoder[seq_i]
			pseudoValue := struct {
				Symbols *LvsTagSymbol
			}{
				Symbols: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Symbols != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Symbols_encoder.Length).EncodingLength())
					l += encoder.Symbols_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the nodes and symbols contexts of the LvsModelParsingContext.
func (context *LvsModelParsingContext) Init() {

	context.Nodes_context.Init()
	context.Symbols_context.Init()
}

// Encodes an LVS model into a binary buffer using TLV (Type-Length-Value) format with specific type tags and nested subencoders for nodes and symbols.
func (encoder *LvsModelEncoder) EncodeInto(value *LvsModel, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(97)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Version).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.StartId).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(105)
	pos += 1

	buf[pos] = byte(enc.Nat(value.NamedPatternCnt).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Nodes != nil {
		for seq_i, seq_v := range value.Nodes {
			pseudoEncoder := &encoder.Nodes_subencoder[seq_i]
			pseudoValue := struct {
				Nodes *LvsNode
			}{
				Nodes: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Nodes != nil {
					buf[pos] = byte(99)
					pos += 1
					pos += uint(enc.TLNum(encoder.Nodes_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Nodes_encoder.Length > 0 {
						encoder.Nodes_encoder.EncodeInto(value.Nodes, buf[pos:])
						pos += encoder.Nodes_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Symbols != nil {
		for seq_i, seq_v := range value.Symbols {
			pseudoEncoder := &encoder.Symbols_subencoder[seq_i]
			pseudoValue := struct {
				Symbols *LvsTagSymbol
			}{
				Symbols: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Symbols != nil {
					buf[pos] = byte(103)
					pos += 1
					pos += uint(enc.TLNum(encoder.Symbols_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Symbols_encoder.Length > 0 {
						encoder.Symbols_encoder.EncodeInto(value.Symbols, buf[pos:])
						pos += encoder.Symbols_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the provided LvsModel into a byte slice of the encoder's specified length, returning it as a wire structure.
func (encoder *LvsModelEncoder) Encode(value *LvsModel) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded LVS model data into an LvsModel struct, handling required fields (Version, StartId, NamedPatternCnt) and delegating Node/Symbol parsing to sub-contexts, with optional critical field ignoring.
func (context *LvsModelParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsModel, error) {

	var handled_Version bool = false
	var handled_StartId bool = false
	var handled_NamedPatternCnt bool = false
	var handled_Nodes bool = false
	var handled_Symbols bool = false

	progress := -1
	_ = progress

	value := &LvsModel{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 97:
				if true {
					handled = true
					handled_Version = true
					value.Version = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Version = uint64(value.Version<<8) | uint64(x)
						}
					}
				}
			case 37:
				if true {
					handled = true
					handled_StartId = true
					value.StartId = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StartId = uint64(value.StartId<<8) | uint64(x)
						}
					}
				}
			case 105:
				if true {
					handled = true
					handled_NamedPatternCnt = true
					value.NamedPatternCnt = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NamedPatternCnt = uint64(value.NamedPatternCnt<<8) | uint64(x)
						}
					}
				}
			case 99:
				if true {
					handled = true
					handled_Nodes = true
					if value.Nodes == nil {
						value.Nodes = make([]*LvsNode, 0)
					}
					{
						pseudoValue := struct {
							Nodes *LvsNode
						}{}
						{
							value := &pseudoValue
							value.Nodes, err = context.Nodes_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Nodes = append(value.Nodes, pseudoValue.Nodes)
					}
					progress--
				}
			case 103:
				if true {
					handled = true
					handled_Symbols = true
					if value.Symbols == nil {
						value.Symbols = make([]*LvsTagSymbol, 0)
					}
					{
						pseudoValue := struct {
							Symbols *LvsTagSymbol
						}{}
						{
							value := &pseudoValue
							value.Symbols, err = context.Symbols_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Symbols = append(value.Symbols, pseudoValue.Symbols)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Version && err == nil {
		err = enc.ErrSkipRequired{Name: "Version", TypeNum: 97}
	}
	if !handled_StartId && err == nil {
		err = enc.ErrSkipRequired{Name: "StartId", TypeNum: 37}
	}
	if !handled_NamedPatternCnt && err == nil {
		err = enc.ErrSkipRequired{Name: "NamedPatternCnt", TypeNum: 105}
	}
	if !handled_Nodes && err == nil {
		// sequence - skip
	}
	if !handled_Symbols && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the LvsModel instance into a wire-format representation using the LvsModelEncoder.
func (value *LvsModel) Encode() enc.Wire {
	encoder := LvsModelEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the LvsModel by encoding its components and joining them into a single slice.
func (value *LvsModel) Bytes() []byte {
	return value.Encode().Join()
}

// Parses an LVS model from the provided wire-encoded data, using a parsing context and optionally ignoring critical errors.
func ParseLvsModel(reader enc.WireView, ignoreCritical bool) (*LvsModel, error) {
	context := LvsModelParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
