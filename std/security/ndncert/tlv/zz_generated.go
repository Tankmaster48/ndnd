// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
	spec "github.com/named-data/ndnd/std/ndn/spec_2022"
)

type CaProfileEncoder struct {
	Length uint

	CaPrefix_encoder spec.NameContainerEncoder

	ParamKey_subencoder []struct {
	}

	CaCert_length uint
}

type CaProfileParsingContext struct {
	CaPrefix_context spec.NameContainerParsingContext
}

// Initializes a CaProfileEncoder with the provided CaProfile value, calculating the total encoded length by aggregating the sizes of all fields (including nested structures like CaPrefix, ParamKey, CaCert, and CaInfo) according to TLV encoding rules.
func (encoder *CaProfileEncoder) Init(value *CaProfile) {
	if value.CaPrefix != nil {
		encoder.CaPrefix_encoder.Init(value.CaPrefix)
	}

	{
		ParamKey_l := len(value.ParamKey)
		encoder.ParamKey_subencoder = make([]struct {
		}, ParamKey_l)
		for i := 0; i < ParamKey_l; i++ {
			pseudoEncoder := &encoder.ParamKey_subencoder[i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: value.ParamKey[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	if value.CaCert != nil {
		encoder.CaCert_length = 0
		for _, c := range value.CaCert {
			encoder.CaCert_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.CaPrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CaPrefix_encoder.Length).EncodingLength())
		l += encoder.CaPrefix_encoder.Length
	}
	l += 1
	l += uint(enc.TLNum(len(value.CaInfo)).EncodingLength())
	l += uint(len(value.CaInfo))
	if value.ParamKey != nil {
		for seq_i, seq_v := range value.ParamKey {
			pseudoEncoder := &encoder.ParamKey_subencoder[seq_i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.ParamKey)).EncodingLength())
				l += uint(len(value.ParamKey))
				_ = encoder
				_ = value
			}
		}
	}
	l += 1
	l += uint(1 + enc.Nat(value.MaxValidPeriod).EncodingLength())
	if value.CaCert != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CaCert_length).EncodingLength())
		l += encoder.CaCert_length
	}
	encoder.Length = l

}

// Initializes the embedded `CaPrefix_context` field by calling its own `Init()` method as part of setting up the `CaProfileParsingContext`.
func (context *CaProfileParsingContext) Init() {
	context.CaPrefix_context.Init()

}

// Encodes a CA profile structure into a binary TLV (Type-Length-Value) format in the provided byte buffer, handling optional fields, string slices, and nested data elements according to NDN encoding rules.
func (encoder *CaProfileEncoder) EncodeInto(value *CaProfile, buf []byte) {

	pos := uint(0)

	if value.CaPrefix != nil {
		buf[pos] = byte(129)
		pos += 1
		pos += uint(enc.TLNum(encoder.CaPrefix_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.CaPrefix_encoder.Length > 0 {
			encoder.CaPrefix_encoder.EncodeInto(value.CaPrefix, buf[pos:])
			pos += encoder.CaPrefix_encoder.Length
		}
	}
	buf[pos] = byte(131)
	pos += 1
	pos += uint(enc.TLNum(len(value.CaInfo)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.CaInfo)
	pos += uint(len(value.CaInfo))
	if value.ParamKey != nil {
		for seq_i, seq_v := range value.ParamKey {
			pseudoEncoder := &encoder.ParamKey_subencoder[seq_i]
			pseudoValue := struct {
				ParamKey string
			}{
				ParamKey: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.ParamKey)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.ParamKey)
				pos += uint(len(value.ParamKey))
				_ = encoder
				_ = value
			}
		}
	}
	buf[pos] = byte(139)
	pos += 1

	buf[pos] = byte(enc.Nat(value.MaxValidPeriod).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.CaCert != nil {
		buf[pos] = byte(137)
		pos += 1
		pos += uint(enc.TLNum(encoder.CaCert_length).EncodeInto(buf[pos:]))
		for _, w := range value.CaCert {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}
}

// Encodes the provided CaProfile into a single TLV wire element using the encoder's predefined length.
func (encoder *CaProfileEncoder) Encode(value *CaProfile) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a CA profile from TLV-encoded input, validating required fields (CaInfo, MaxValidPeriod) and processing optional/critical components (CaPrefix, ParamKey, CaCert) according to the provided parsing context and ignoreCritical flag.
func (context *CaProfileParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*CaProfile, error) {

	var handled_CaPrefix bool = false
	var handled_CaInfo bool = false
	var handled_ParamKey bool = false
	var handled_MaxValidPeriod bool = false
	var handled_CaCert bool = false

	progress := -1
	_ = progress

	value := &CaProfile{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 129:
				if true {
					handled = true
					handled_CaPrefix = true
					value.CaPrefix, err = context.CaPrefix_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 131:
				if true {
					handled = true
					handled_CaInfo = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.CaInfo = builder.String()
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_ParamKey = true
					if value.ParamKey == nil {
						value.ParamKey = make([]string, 0)
					}
					{
						pseudoValue := struct {
							ParamKey string
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int(l))
								if err == nil {
									value.ParamKey = builder.String()
								}
							}
							_ = value
						}
						value.ParamKey = append(value.ParamKey, pseudoValue.ParamKey)
					}
					progress--
				}
			case 139:
				if true {
					handled = true
					handled_MaxValidPeriod = true
					value.MaxValidPeriod = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.MaxValidPeriod = uint64(value.MaxValidPeriod<<8) | uint64(x)
						}
					}
				}
			case 137:
				if true {
					handled = true
					handled_CaCert = true
					value.CaCert, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_CaPrefix && err == nil {
		value.CaPrefix = nil
	}
	if !handled_CaInfo && err == nil {
		err = enc.ErrSkipRequired{Name: "CaInfo", TypeNum: 131}
	}
	if !handled_ParamKey && err == nil {
		// sequence - skip
	}
	if !handled_MaxValidPeriod && err == nil {
		err = enc.ErrSkipRequired{Name: "MaxValidPeriod", TypeNum: 139}
	}
	if !handled_CaCert && err == nil {
		value.CaCert = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the CaProfile instance into a wire-compatible format using the CaProfileEncoder for transmission or storage.
func (value *CaProfile) Encode() enc.Wire {
	encoder := CaProfileEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the concatenated byte slice of the encoded CA profile components.
func (value *CaProfile) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a CA profile from the provided wire-format input, using the specified flag to determine whether to ignore critical fields that cannot be processed.
func ParseCaProfile(reader enc.WireView, ignoreCritical bool) (*CaProfile, error) {
	context := CaProfileParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeReqEncoder struct {
	Length uint

	Params_valencoder map[string]*struct {
	}
}

type ProbeReqParsingContext struct {
}

// Initializes the ProbeReqEncoder with the provided ProbeReq value, calculating the total encoded length by summing the TLV-encoded sizes of all key-value pairs in the Params map.
func (encoder *ProbeReqEncoder) Init(value *ProbeReq) {
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the ProbeReqParsingContext for parsing probe request data.
func (context *ProbeReqParsingContext) Init() {

}

// Encodes a ProbeReq's parameters into a binary buffer using TLV (Type-Length-Value) format, with type 0x85 for parameter keys and 0x87 for their corresponding byte string values.
func (encoder *ProbeReqEncoder) EncodeInto(value *ProbeReq, buf []byte) {

	pos := uint(0)

	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a ProbeReq object into a binary wire format slice using the encoder's specified length.
func (encoder *ProbeReqEncoder) Encode(value *ProbeReq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a ProbeReq structure from a binary-encoded wire format, extracting parameters into a map and handling critical/unknown fields based on the ignoreCritical flag.
func (context *ProbeReqParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ProbeReq, error) {

	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ProbeReq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the ProbeReq into a wire representation using a ProbeReqEncoder.
func (value *ProbeReq) Encode() enc.Wire {
	encoder := ProbeReqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the ProbeReq structure into a contiguous byte slice for network transmission.
func (value *ProbeReq) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a ProbeReq from wire format data, optionally ignoring critical parsing errors.
func ParseProbeReq(reader enc.WireView, ignoreCritical bool) (*ProbeReq, error) {
	context := ProbeReqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeResValsEncoder struct {
	Length uint

	Response_length uint
}

type ProbeResValsParsingContext struct {
}

// Initializes the encoder by calculating the total encoded length of the ProbeResVals, including the Response and MaxSuffixLength fields, to set the overall encoding length required for TLV serialization.
func (encoder *ProbeResValsEncoder) Init(value *ProbeResVals) {
	if value.Response != nil {
		encoder.Response_length = 0
		for _, c := range value.Response {
			encoder.Response_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Response != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Response_length).EncodingLength())
		l += encoder.Response_length
	}
	if optval, ok := value.MaxSuffixLength.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	encoder.Length = l

}

// Initializes the ProbeResValsParsingContext for parsing probe response values.
func (context *ProbeResValsParsingContext) Init() {

}

// Encodes a ProbeResVals structure into a byte buffer using TLV (Type-Length-Value) format, including a list of response values (type 7) and an optional max suffix length (type 143).
func (encoder *ProbeResValsEncoder) EncodeInto(value *ProbeResVals, buf []byte) {

	pos := uint(0)

	if value.Response != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Response_length).EncodeInto(buf[pos:]))
		for _, c := range value.Response {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if optval, ok := value.MaxSuffixLength.Get(); ok {
		buf[pos] = byte(143)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
}

// Encodes the provided ProbeResVals value into a byte slice of the encoder's specified length, returning it as a Wire structure containing the serialized data.
func (encoder *ProbeResValsEncoder) Encode(value *ProbeResVals) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded ProbeResVals structure, extracting the Response name and MaxSuffixLength fields while handling critical and non-critical unknown fields according to the ignoreCritical flag.
func (context *ProbeResValsParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ProbeResVals, error) {

	var handled_Response bool = false
	var handled_MaxSuffixLength bool = false

	progress := -1
	_ = progress

	value := &ProbeResVals{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Response = true
					delegate := reader.Delegate(int(l))
					value.Response, err = delegate.ReadName()
				}
			case 143:
				if true {
					handled = true
					handled_MaxSuffixLength = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.MaxSuffixLength.Set(optval)
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Response && err == nil {
		value.Response = nil
	}
	if !handled_MaxSuffixLength && err == nil {
		value.MaxSuffixLength.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the ProbeResVals instance into a wire-encoded format using a dedicated encoder for network transmission or storage.
func (value *ProbeResVals) Encode() enc.Wire {
	encoder := ProbeResValsEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns a byte slice representation of the ProbeResVals by encoding its fields and concatenating the resulting components.
func (value *ProbeResVals) Bytes() []byte {
	return value.Encode().Join()
}

// Parses encoded probe response values into a ProbeResVals object using the provided WireView reader, with an option to ignore critical parsing errors.
func ParseProbeResVals(reader enc.WireView, ignoreCritical bool) (*ProbeResVals, error) {
	context := ProbeResValsParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ProbeResEncoder struct {
	Length uint

	Vals_subencoder []struct {
		Vals_encoder ProbeResValsEncoder
	}
	RedirectPrefix_encoder spec.NameContainerEncoder
}

type ProbeResParsingContext struct {
	Vals_context           ProbeResValsParsingContext
	RedirectPrefix_context spec.NameContainerParsingContext
}

// Initializes the encoder for a ProbeRes object by setting up sub-encoders for its Vals slice and RedirectPrefix, then calculates the total encoded length including TLV overhead for each component.
func (encoder *ProbeResEncoder) Init(value *ProbeRes) {
	{
		Vals_l := len(value.Vals)
		encoder.Vals_subencoder = make([]struct {
			Vals_encoder ProbeResValsEncoder
		}, Vals_l)
		for i := 0; i < Vals_l; i++ {
			pseudoEncoder := &encoder.Vals_subencoder[i]
			pseudoValue := struct {
				Vals *ProbeResVals
			}{
				Vals: value.Vals[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					encoder.Vals_encoder.Init(value.Vals)
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.RedirectPrefix != nil {
		encoder.RedirectPrefix_encoder.Init(value.RedirectPrefix)
	}

	l := uint(0)
	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *ProbeResVals
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Vals_encoder.Length).EncodingLength())
					l += encoder.Vals_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.RedirectPrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.RedirectPrefix_encoder.Length).EncodingLength())
		l += encoder.RedirectPrefix_encoder.Length
	}
	encoder.Length = l

}

// Initializes the ProbeResParsingContext by initializing its Vals_context and RedirectPrefix_context sub-contexts.
func (context *ProbeResParsingContext) Init() {
	context.Vals_context.Init()
	context.RedirectPrefix_context.Init()
}

// Encodes a ProbeRes structure into a binary buffer using TLV (Type-Length-Value) encoding for its fields, including a slice of ProbeResVals and an optional RedirectPrefix.
func (encoder *ProbeResEncoder) EncodeInto(value *ProbeRes, buf []byte) {

	pos := uint(0)

	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *ProbeResVals
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					buf[pos] = byte(141)
					pos += 1
					pos += uint(enc.TLNum(encoder.Vals_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Vals_encoder.Length > 0 {
						encoder.Vals_encoder.EncodeInto(value.Vals, buf[pos:])
						pos += encoder.Vals_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.RedirectPrefix != nil {
		buf[pos] = byte(179)
		pos += 1
		pos += uint(enc.TLNum(encoder.RedirectPrefix_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.RedirectPrefix_encoder.Length > 0 {
			encoder.RedirectPrefix_encoder.EncodeInto(value.RedirectPrefix, buf[pos:])
			pos += encoder.RedirectPrefix_encoder.Length
		}
	}
}

// Serializes a ProbeRes value into a byte slice of size determined by the encoder's Length field and returns it as an enc.Wire structure.
func (encoder *ProbeResEncoder) Encode(value *ProbeRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a ProbeRes structure from TLV-encoded wire data, handling nested Vals and RedirectPrefix fields while respecting critical field constraints based on the ignoreCritical flag.
func (context *ProbeResParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ProbeRes, error) {

	var handled_Vals bool = false
	var handled_RedirectPrefix bool = false

	progress := -1
	_ = progress

	value := &ProbeRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 141:
				if true {
					handled = true
					handled_Vals = true
					if value.Vals == nil {
						value.Vals = make([]*ProbeResVals, 0)
					}
					{
						pseudoValue := struct {
							Vals *ProbeResVals
						}{}
						{
							value := &pseudoValue
							value.Vals, err = context.Vals_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Vals = append(value.Vals, pseudoValue.Vals)
					}
					progress--
				}
			case 179:
				if true {
					handled = true
					handled_RedirectPrefix = true
					value.RedirectPrefix, err = context.RedirectPrefix_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Vals && err == nil {
		// sequence - skip
	}
	if !handled_RedirectPrefix && err == nil {
		value.RedirectPrefix = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the ProbeRes object into a wire format using the ProbeResEncoder.
func (value *ProbeRes) Encode() enc.Wire {
	encoder := ProbeResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the ProbeRes by encoding its components and concatenating them into a single byte slice.
func (value *ProbeRes) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a ProbeRes object from wire format data using a newly initialized parsing context, with an option to ignore critical parsing errors.
func ParseProbeRes(reader enc.WireView, ignoreCritical bool) (*ProbeRes, error) {
	context := ProbeResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NewReqEncoder struct {
	Length uint

	CertReq_length uint
}

type NewReqParsingContext struct {
}

// Calculates the total encoded length of the NewReq message components (EcdhPub and CertReq) and sets the encoder's Length field to prepare for serialization.
func (encoder *NewReqEncoder) Init(value *NewReq) {

	if value.CertReq != nil {
		encoder.CertReq_length = 0
		for _, c := range value.CertReq {
			encoder.CertReq_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.EcdhPub != nil {
		l += 1
		l += uint(enc.TLNum(len(value.EcdhPub)).EncodingLength())
		l += uint(len(value.EcdhPub))
	}
	if value.CertReq != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CertReq_length).EncodingLength())
		l += encoder.CertReq_length
	}
	encoder.Length = l

}

// Initializes the parsing context, serving as a customizable hook for subclasses to set up specific parsing logic or state.
func (context *NewReqParsingContext) Init() {

}

// Encodes a NewReq object into a binary buffer using TLV (Type-Length-Value) format, writing the ECDH public key (type 145) and certificate request components (type 147) with their respective lengths and values.
func (encoder *NewReqEncoder) EncodeInto(value *NewReq, buf []byte) {

	pos := uint(0)

	if value.EcdhPub != nil {
		buf[pos] = byte(145)
		pos += 1
		pos += uint(enc.TLNum(len(value.EcdhPub)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.EcdhPub)
		pos += uint(len(value.EcdhPub))
	}
	if value.CertReq != nil {
		buf[pos] = byte(147)
		pos += 1
		pos += uint(enc.TLNum(encoder.CertReq_length).EncodeInto(buf[pos:]))
		for _, w := range value.CertReq {
			copy(buf[pos:], w)
			pos += uint(len(w))
		}
	}
}

// Encodes a NewReq request into a wire-format byte slice using the encoder's precomputed length.
func (encoder *NewReqEncoder) Encode(value *NewReq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded wire format into a NewReq structure, handling ECDH public key (type 145) and certificate request (type 147) fields, while skipping or rejecting unknown critical fields based on the ignoreCritical flag.
func (context *NewReqParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NewReq, error) {

	var handled_EcdhPub bool = false
	var handled_CertReq bool = false

	progress := -1
	_ = progress

	value := &NewReq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 145:
				if true {
					handled = true
					handled_EcdhPub = true
					value.EcdhPub = make([]byte, l)
					_, err = reader.ReadFull(value.EcdhPub)
				}
			case 147:
				if true {
					handled = true
					handled_CertReq = true
					value.CertReq, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_EcdhPub && err == nil {
		value.EcdhPub = nil
	}
	if !handled_CertReq && err == nil {
		value.CertReq = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the NewReq object into a wire format representation using a NewReqEncoder for transmission or storage.
func (value *NewReq) Encode() enc.Wire {
	encoder := NewReqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the NewReq object into a TLV-encoded byte slice for network transmission.
func (value *NewReq) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a NewReq object from wire-format input, optionally ignoring critical parsing errors.
func ParseNewReq(reader enc.WireView, ignoreCritical bool) (*NewReq, error) {
	context := NewReqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NewResEncoder struct {
	Length uint

	Challenge_subencoder []struct {
	}
}

type NewResParsingContext struct {
}

// Initializes the encoder by calculating the total encoded length of a NewRes structure, accounting for optional fields (EcdhPub, Salt, ReqId) and a sequence of Challenge strings using TLV encoding rules.
func (encoder *NewResEncoder) Init(value *NewRes) {

	{
		Challenge_l := len(value.Challenge)
		encoder.Challenge_subencoder = make([]struct {
		}, Challenge_l)
		for i := 0; i < Challenge_l; i++ {
			pseudoEncoder := &encoder.Challenge_subencoder[i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: value.Challenge[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.EcdhPub != nil {
		l += 1
		l += uint(enc.TLNum(len(value.EcdhPub)).EncodingLength())
		l += uint(len(value.EcdhPub))
	}
	if value.Salt != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Salt)).EncodingLength())
		l += uint(len(value.Salt))
	}
	if value.ReqId != nil {
		l += 1
		l += uint(enc.TLNum(len(value.ReqId)).EncodingLength())
		l += uint(len(value.ReqId))
	}
	if value.Challenge != nil {
		for seq_i, seq_v := range value.Challenge {
			pseudoEncoder := &encoder.Challenge_subencoder[seq_i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Challenge)).EncodingLength())
				l += uint(len(value.Challenge))
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes a NewResParsingContext, preparing it for resource parsing operations.
func (context *NewResParsingContext) Init() {

}

// Encodes a NewRes struct into a binary TLV (Type-Length-Value) format in the provided buffer, handling optional fields (EcdhPub, Salt, ReqId) and a slice of Challenge strings by sequentially writing their type identifiers, encoded lengths, and raw values.
func (encoder *NewResEncoder) EncodeInto(value *NewRes, buf []byte) {

	pos := uint(0)

	if value.EcdhPub != nil {
		buf[pos] = byte(145)
		pos += 1
		pos += uint(enc.TLNum(len(value.EcdhPub)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.EcdhPub)
		pos += uint(len(value.EcdhPub))
	}
	if value.Salt != nil {
		buf[pos] = byte(149)
		pos += 1
		pos += uint(enc.TLNum(len(value.Salt)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Salt)
		pos += uint(len(value.Salt))
	}
	if value.ReqId != nil {
		buf[pos] = byte(151)
		pos += 1
		pos += uint(enc.TLNum(len(value.ReqId)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.ReqId)
		pos += uint(len(value.ReqId))
	}
	if value.Challenge != nil {
		for seq_i, seq_v := range value.Challenge {
			pseudoEncoder := &encoder.Challenge_subencoder[seq_i]
			pseudoValue := struct {
				Challenge string
			}{
				Challenge: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(153)
				pos += 1
				pos += uint(enc.TLNum(len(value.Challenge)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Challenge)
				pos += uint(len(value.Challenge))
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a `NewRes` object into a byte slice using the encoder's precomputed length, returning it as a `enc.Wire` structure for packet serialization.
func (encoder *NewResEncoder) Encode(value *NewRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded wire format into a NewRes structure, handling optional fields like ECDH public key, salt, request ID, and challenges, with optional skipping of unrecognized critical fields based on the ignoreCritical flag.
func (context *NewResParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*NewRes, error) {

	var handled_EcdhPub bool = false
	var handled_Salt bool = false
	var handled_ReqId bool = false
	var handled_Challenge bool = false

	progress := -1
	_ = progress

	value := &NewRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 145:
				if true {
					handled = true
					handled_EcdhPub = true
					value.EcdhPub = make([]byte, l)
					_, err = reader.ReadFull(value.EcdhPub)
				}
			case 149:
				if true {
					handled = true
					handled_Salt = true
					value.Salt = make([]byte, l)
					_, err = reader.ReadFull(value.Salt)
				}
			case 151:
				if true {
					handled = true
					handled_ReqId = true
					value.ReqId = make([]byte, l)
					_, err = reader.ReadFull(value.ReqId)
				}
			case 153:
				if true {
					handled = true
					handled_Challenge = true
					if value.Challenge == nil {
						value.Challenge = make([]string, 0)
					}
					{
						pseudoValue := struct {
							Challenge string
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int(l))
								if err == nil {
									value.Challenge = builder.String()
								}
							}
							_ = value
						}
						value.Challenge = append(value.Challenge, pseudoValue.Challenge)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_EcdhPub && err == nil {
		value.EcdhPub = nil
	}
	if !handled_Salt && err == nil {
		value.Salt = nil
	}
	if !handled_ReqId && err == nil {
		value.ReqId = nil
	}
	if !handled_Challenge && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the NewRes value into its wire format representation using a NewResEncoder.
func (value *NewRes) Encode() enc.Wire {
	encoder := NewResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte representation of the NewRes value by joining the results of its Encode method.
func (value *NewRes) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a NewRes structure from the provided encoded data, initializing a parsing context and allowing optional ignoring of critical fields.
func ParseNewRes(reader enc.WireView, ignoreCritical bool) (*NewRes, error) {
	context := NewResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CipherMsgEncoder struct {
	Length uint
}

type CipherMsgParsingContext struct {
}

// Calculates the total encoded length of a CipherMsg by summing the size contributions of its optional fields (InitVec, AuthNTag, Payload) including TLV encoding overhead, and sets this length on the encoder.
func (encoder *CipherMsgEncoder) Init(value *CipherMsg) {

	l := uint(0)
	if value.InitVec != nil {
		l += 1
		l += uint(enc.TLNum(len(value.InitVec)).EncodingLength())
		l += uint(len(value.InitVec))
	}
	if value.AuthNTag != nil {
		l += 1
		l += uint(enc.TLNum(len(value.AuthNTag)).EncodingLength())
		l += uint(len(value.AuthNTag))
	}
	if value.Payload != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Payload)).EncodingLength())
		l += uint(len(value.Payload))
	}
	encoder.Length = l

}

// Initializes the CipherMsgParsingContext, preparing it for parsing operations (currently a no-op in this implementation).
func (context *CipherMsgParsingContext) Init() {

}

// Serializes a CipherMsg into a binary buffer, encoding non-nil fields (InitVec, AuthNTag, Payload) with type identifiers, length prefixes, and raw data.
func (encoder *CipherMsgEncoder) EncodeInto(value *CipherMsg, buf []byte) {

	pos := uint(0)

	if value.InitVec != nil {
		buf[pos] = byte(157)
		pos += 1
		pos += uint(enc.TLNum(len(value.InitVec)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.InitVec)
		pos += uint(len(value.InitVec))
	}
	if value.AuthNTag != nil {
		buf[pos] = byte(175)
		pos += 1
		pos += uint(enc.TLNum(len(value.AuthNTag)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.AuthNTag)
		pos += uint(len(value.AuthNTag))
	}
	if value.Payload != nil {
		buf[pos] = byte(159)
		pos += 1
		pos += uint(enc.TLNum(len(value.Payload)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Payload)
		pos += uint(len(value.Payload))
	}
}

// Encodes a `CipherMsg` into a pre-allocated byte buffer of size `encoder.Length` and returns it as a `Wire` structure containing the serialized data.
func (encoder *CipherMsgEncoder) Encode(value *CipherMsg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded cipher message into a CipherMsg structure, extracting initialization vector (InitVec), authentication tag (AuthNTag), and payload, while handling unrecognized critical fields according to the ignoreCritical flag.
func (context *CipherMsgParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*CipherMsg, error) {

	var handled_InitVec bool = false
	var handled_AuthNTag bool = false
	var handled_Payload bool = false

	progress := -1
	_ = progress

	value := &CipherMsg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 157:
				if true {
					handled = true
					handled_InitVec = true
					value.InitVec = make([]byte, l)
					_, err = reader.ReadFull(value.InitVec)
				}
			case 175:
				if true {
					handled = true
					handled_AuthNTag = true
					value.AuthNTag = make([]byte, l)
					_, err = reader.ReadFull(value.AuthNTag)
				}
			case 159:
				if true {
					handled = true
					handled_Payload = true
					value.Payload = make([]byte, l)
					_, err = reader.ReadFull(value.Payload)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_InitVec && err == nil {
		value.InitVec = nil
	}
	if !handled_AuthNTag && err == nil {
		value.AuthNTag = nil
	}
	if !handled_Payload && err == nil {
		value.Payload = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the CipherMsg value into a Wire format using a CipherMsgEncoder.
func (value *CipherMsg) Encode() enc.Wire {
	encoder := CipherMsgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded cipher message as a concatenated byte slice.
func (value *CipherMsg) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a cipher message from the provided encoded data using a parsing context, with an option to ignore critical fields not recognized during decoding.
func ParseCipherMsg(reader enc.WireView, ignoreCritical bool) (*CipherMsg, error) {
	context := CipherMsgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChallengeReqEncoder struct {
	Length uint

	Params_valencoder map[string]*struct {
	}
}

type ChallengeReqParsingContext struct {
}

// Initializes a ChallengeReqEncoder with the given ChallengeReq value, calculating the total encoded length required for the challenge and its parameters, including TLV encoding overhead.
func (encoder *ChallengeReqEncoder) Init(value *ChallengeReq) {

	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(enc.TLNum(len(value.Challenge)).EncodingLength())
	l += uint(len(value.Challenge))
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the parsing context for a challenge request, establishing default state or configuration required for subsequent processing.
func (context *ChallengeReqParsingContext) Init() {

}

// Serializes a ChallengeReq object into a TLV-encoded byte slice, including a challenge payload and optional key-value parameters with distinct type identifiers for each component.
func (encoder *ChallengeReqEncoder) EncodeInto(value *ChallengeReq, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(161)
	pos += 1
	pos += uint(enc.TLNum(len(value.Challenge)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Challenge)
	pos += uint(len(value.Challenge))
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a ChallengeReq value into a wire-encoded byte slice using the encoder's specified length.
func (encoder *ChallengeReqEncoder) Encode(value *ChallengeReq) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary-encoded ChallengeReq structure from a WireView, extracting required Challenge field (type 161) and optional Params map (type 133) while handling TLV encoding and critical field validation based on ignoreCritical flag.
func (context *ChallengeReqParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ChallengeReq, error) {

	var handled_Challenge bool = false
	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ChallengeReq{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 161:
				if true {
					handled = true
					handled_Challenge = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Challenge = builder.String()
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Challenge && err == nil {
		err = enc.ErrSkipRequired{Name: "Challenge", TypeNum: 161}
	}
	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the ChallengeReq object into a wire format for transmission using a dedicated encoder.
func (value *ChallengeReq) Encode() enc.Wire {
	encoder := ChallengeReqEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte slice of the ChallengeReq by concatenating its encoded components.
func (value *ChallengeReq) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a ChallengeReq structure from wire-encoded data using a parsing context, with an option to ignore critical fields if specified.
func ParseChallengeReq(reader enc.WireView, ignoreCritical bool) (*ChallengeReq, error) {
	context := ChallengeReqParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChallengeResEncoder struct {
	Length uint

	CertName_encoder       spec.NameContainerEncoder
	ForwardingHint_encoder spec.NameContainerEncoder
	Params_valencoder      map[string]*struct {
	}
}

type ChallengeResParsingContext struct {
	CertName_context       spec.NameContainerParsingContext
	ForwardingHint_context spec.NameContainerParsingContext
}

// Initializes the encoder with the provided ChallengeRes data structure, computing the total encoded length by accounting for all mandatory and optional TLV-encoded fields, including nested elements like CertName, ForwardingHint, and key-value Params.
func (encoder *ChallengeResEncoder) Init(value *ChallengeRes) {

	if value.CertName != nil {
		encoder.CertName_encoder.Init(value.CertName)
	}
	if value.ForwardingHint != nil {
		encoder.ForwardingHint_encoder.Init(value.ForwardingHint)
	}
	{
		Params_l := len(value.Params)
		encoder.Params_valencoder = make(map[string]*struct {
		}, Params_l)
		for map_k := range value.Params {
			pseudoEncoder := &struct {
			}{}
			encoder.Params_valencoder[map_k] = pseudoEncoder
			pseudoValue := struct {
				Params_v []byte
			}{
				Params_v: value.Params[map_k],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Status).EncodingLength())
	if optval, ok := value.ChalStatus.Get(); ok {
		l += 1
		l += uint(enc.TLNum(len(optval)).EncodingLength())
		l += uint(len(optval))
	}
	if optval, ok := value.RemainTries.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.RemainTime.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.CertName != nil {
		l += 1
		l += uint(enc.TLNum(encoder.CertName_encoder.Length).EncodingLength())
		l += encoder.CertName_encoder.Length
	}
	if value.ForwardingHint != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ForwardingHint_encoder.Length).EncodingLength())
		l += encoder.ForwardingHint_encoder.Length
	}
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(enc.TLNum(len(value.Params_k)).EncodingLength())
				l += uint(len(value.Params_k))
				if value.Params_v != nil {
					l += 1
					l += uint(enc.TLNum(len(value.Params_v)).EncodingLength())
					l += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the certificate name and forwarding hint sub-contexts of the ChallengeResParsingContext.
func (context *ChallengeResParsingContext) Init() {

	context.CertName_context.Init()
	context.ForwardingHint_context.Init()

}

// Encodes a ChallengeRes object into a TLV (Type-Length-Value) formatted byte slice, including optional fields like ChalStatus, RemainTries, and RemainTime, as well as nested structures such as CertName, ForwardingHint, and key-value parameter maps.
func (encoder *ChallengeResEncoder) EncodeInto(value *ChallengeRes, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(155)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Status).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if optval, ok := value.ChalStatus.Get(); ok {
		buf[pos] = byte(163)
		pos += 1
		pos += uint(enc.TLNum(len(optval)).EncodeInto(buf[pos:]))
		copy(buf[pos:], optval)
		pos += uint(len(optval))
	}
	if optval, ok := value.RemainTries.Get(); ok {
		buf[pos] = byte(165)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.RemainTime.Get(); ok {
		buf[pos] = byte(167)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.CertName != nil {
		buf[pos] = byte(169)
		pos += 1
		pos += uint(enc.TLNum(encoder.CertName_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.CertName_encoder.Length > 0 {
			encoder.CertName_encoder.EncodeInto(value.CertName, buf[pos:])
			pos += encoder.CertName_encoder.Length
		}
	}
	if value.ForwardingHint != nil {
		buf[pos] = byte(30)
		pos += 1
		pos += uint(enc.TLNum(encoder.ForwardingHint_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.ForwardingHint_encoder.Length > 0 {
			encoder.ForwardingHint_encoder.EncodeInto(value.ForwardingHint, buf[pos:])
			pos += encoder.ForwardingHint_encoder.Length
		}
	}
	if value.Params != nil {
		for map_k, map_v := range value.Params {
			pseudoEncoder := encoder.Params_valencoder[map_k]
			pseudoValue := struct {
				Params_k string
				Params_v []byte
			}{
				Params_k: map_k,
				Params_v: map_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(133)
				pos += 1
				pos += uint(enc.TLNum(len(value.Params_k)).EncodeInto(buf[pos:]))
				copy(buf[pos:], value.Params_k)
				pos += uint(len(value.Params_k))
				if value.Params_v != nil {
					buf[pos] = byte(135)
					pos += 1
					pos += uint(enc.TLNum(len(value.Params_v)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Params_v)
					pos += uint(len(value.Params_v))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a ChallengeRes value into a pre-allocated byte buffer of size determined by the encoder and returns it wrapped in a single-element enc.Wire slice.
func (encoder *ChallengeResEncoder) Encode(value *ChallengeRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary TLV-encoded ChallengeRes structure from a reader, decoding fields like status, challenge status, remaining attempts/time, certificate name, forwarding hint, and parameters, while enforcing required fields and handling critical extensions based on the ignoreCritical flag.
func (context *ChallengeResParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ChallengeRes, error) {

	var handled_Status bool = false
	var handled_ChalStatus bool = false
	var handled_RemainTries bool = false
	var handled_RemainTime bool = false
	var handled_CertName bool = false
	var handled_ForwardingHint bool = false
	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ChallengeRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 155:
				if true {
					handled = true
					handled_Status = true
					value.Status = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Status = uint64(value.Status<<8) | uint64(x)
						}
					}
				}
			case 163:
				if true {
					handled = true
					handled_ChalStatus = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.ChalStatus.Set(builder.String())
						}
					}
				}
			case 165:
				if true {
					handled = true
					handled_RemainTries = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.RemainTries.Set(optval)
					}
				}
			case 167:
				if true {
					handled = true
					handled_RemainTime = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.RemainTime.Set(optval)
					}
				}
			case 169:
				if true {
					handled = true
					handled_CertName = true
					value.CertName, err = context.CertName_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 30:
				if true {
					handled = true
					handled_ForwardingHint = true
					value.ForwardingHint, err = context.ForwardingHint_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 133:
				if true {
					handled = true
					handled_Params = true
					if value.Params == nil {
						value.Params = make(map[string][]byte)
					}
					{
						pseudoValue := struct {
							Params_k string
							Params_v []byte
						}{}
						{
							value := &pseudoValue
							{
								var builder strings.Builder
								_, err = reader.CopyN(&builder, int(l))
								if err == nil {
									value.Params_k = builder.String()
								}
							}
							typ := enc.TLNum(0)
							l := enc.TLNum(0)
							typ, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							l, err = reader.ReadTLNum()
							if err != nil {
								return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
							}
							if typ != 135 {
								return nil, enc.ErrFailToParse{TypeNum: 133, Err: enc.ErrUnrecognizedField{TypeNum: typ}}
							}
							value.Params_v = make([]byte, l)
							_, err = reader.ReadFull(value.Params_v)
							_ = value
						}
						value.Params[pseudoValue.Params_k] = pseudoValue.Params_v
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Status && err == nil {
		err = enc.ErrSkipRequired{Name: "Status", TypeNum: 155}
	}
	if !handled_ChalStatus && err == nil {
		value.ChalStatus.Unset()
	}
	if !handled_RemainTries && err == nil {
		value.RemainTries.Unset()
	}
	if !handled_RemainTime && err == nil {
		value.RemainTime.Unset()
	}
	if !handled_CertName && err == nil {
		value.CertName = nil
	}
	if !handled_ForwardingHint && err == nil {
		value.ForwardingHint = nil
	}
	if !handled_Params && err == nil {
		// map - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// "Encodes the ChallengeRes value into a wire format representation using the ChallengeResEncoder."
func (value *ChallengeRes) Encode() enc.Wire {
	encoder := ChallengeResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the ChallengeRes value by encoding its components and joining them into a single byte slice.
func (value *ChallengeRes) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a ChallengeRes from the provided wire format input, optionally ignoring unknown critical fields.
func ParseChallengeRes(reader enc.WireView, ignoreCritical bool) (*ChallengeRes, error) {
	context := ChallengeResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ErrorResEncoder struct {
	Length uint
}

type ErrorResParsingContext struct {
}

// Initializes the ErrorResEncoder by calculating and setting the total encoded length of the ErrorRes message, accounting for fixed overhead, encoded error code, and variable-length error information.
func (encoder *ErrorResEncoder) Init(value *ErrorRes) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.ErrCode).EncodingLength())
	l += 1
	l += uint(enc.TLNum(len(value.ErrInfo)).EncodingLength())
	l += uint(len(value.ErrInfo))
	encoder.Length = l

}

// Initializes the ErrorResParsingContext, preparing it for parsing error responses.
func (context *ErrorResParsingContext) Init() {

}

// Encodes an ErrorRes object into a binary TLV format in the provided buffer, including an error code (as a variable-length integer) and error information (as a string with length prefix).
func (encoder *ErrorResEncoder) EncodeInto(value *ErrorRes, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(171)
	pos += 1

	buf[pos] = byte(enc.Nat(value.ErrCode).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(173)
	pos += 1
	pos += uint(enc.TLNum(len(value.ErrInfo)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.ErrInfo)
	pos += uint(len(value.ErrInfo))
}

// Encodes an ErrorRes into a wire format by allocating a buffer of the encoder's specified length and populating it with the encoded data.
func (encoder *ErrorResEncoder) Encode(value *ErrorRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary wire-encoded NDN Error Response (ErrorRes) by reading and validating the ErrCode (type 171) and ErrInfo (type 173) fields, with optional skipping of unrecognized critical fields based on the ignoreCritical flag.
func (context *ErrorResParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ErrorRes, error) {

	var handled_ErrCode bool = false
	var handled_ErrInfo bool = false

	progress := -1
	_ = progress

	value := &ErrorRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 171:
				if true {
					handled = true
					handled_ErrCode = true
					value.ErrCode = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.ErrCode = uint64(value.ErrCode<<8) | uint64(x)
						}
					}
				}
			case 173:
				if true {
					handled = true
					handled_ErrInfo = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.ErrInfo = builder.String()
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ErrCode && err == nil {
		err = enc.ErrSkipRequired{Name: "ErrCode", TypeNum: 171}
	}
	if !handled_ErrInfo && err == nil {
		err = enc.ErrSkipRequired{Name: "ErrInfo", TypeNum: 173}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes an ErrorRes into a wire format using ErrorResEncoder.
func (value *ErrorRes) Encode() enc.Wire {
	encoder := ErrorResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the ErrorRes by encoding its components and joining them into a single byte slice.
func (value *ErrorRes) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-format ErrorRes packet using the provided encoder and critical error handling flag.  

**Example:** Parses a wire-format ErrorRes packet into a structured object, optionally ignoring critical parsing errors.
func ParseErrorRes(reader enc.WireView, ignoreCritical bool) (*ErrorRes, error) {
	context := ErrorResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
