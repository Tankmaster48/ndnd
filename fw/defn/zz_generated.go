// Code generated by ndn tlv codegen DO NOT EDIT.
package defn

import (
	"encoding/binary"
	"io"

	"time"

	enc "github.com/named-data/ndnd/std/encoding"
)

type FwPacketEncoder struct {
	Length uint

	wirePlan []uint

	Interest_encoder FwInterestEncoder
	Data_encoder     FwDataEncoder
	LpPacket_encoder FwLpPacketEncoder
}

type FwPacketParsingContext struct {
	Interest_context FwInterestParsingContext
	Data_context     FwDataParsingContext
	LpPacket_context FwLpPacketParsingContext
}

// Initializes the encoder for a Forwarding Packet by setting up component encoders, calculating the total encoded length, and generating a wire encoding plan for the packet's Interest, Data, or LP packet components.
func (encoder *FwPacketEncoder) Init(value *FwPacket) {
	if value.Interest != nil {
		encoder.Interest_encoder.Init(value.Interest)
	}
	if value.Data != nil {
		encoder.Data_encoder.Init(value.Data)
	}
	if value.LpPacket != nil {
		encoder.LpPacket_encoder.Init(value.LpPacket)
	}

	l := uint(0)
	if value.Interest != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Interest_encoder.Length).EncodingLength())
		l += encoder.Interest_encoder.Length
	}
	if value.Data != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Data_encoder.Length).EncodingLength())
		l += encoder.Data_encoder.Length
	}
	if value.LpPacket != nil {
		l += 1
		l += uint(enc.TLNum(encoder.LpPacket_encoder.Length).EncodingLength())
		l += encoder.LpPacket_encoder.Length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Interest != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Interest_encoder.Length).EncodingLength())
		if encoder.Interest_encoder.Length > 0 {
			l += encoder.Interest_encoder.wirePlan[0]
			for i := 1; i < len(encoder.Interest_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.Interest_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if value.Data != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Data_encoder.Length).EncodingLength())
		if encoder.Data_encoder.Length > 0 {
			l += encoder.Data_encoder.wirePlan[0]
			for i := 1; i < len(encoder.Data_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.Data_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if value.LpPacket != nil {
		l += 1
		l += uint(enc.TLNum(encoder.LpPacket_encoder.Length).EncodingLength())
		if encoder.LpPacket_encoder.Length > 0 {
			l += encoder.LpPacket_encoder.wirePlan[0]
			for i := 1; i < len(encoder.LpPacket_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.LpPacket_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the parsing contexts for Interest, Data, and LpPacket components within the forwarder packet parsing framework.
func (context *FwPacketParsingContext) Init() {
	context.Interest_context.Init()
	context.Data_context.Init()
	context.LpPacket_context.Init()
}

// Encodes a ForwardingPacket (FwPacket) into a TLV-based wire format, handling nested Interest, Data, and LpPacket components by delegating to their respective encoders and managing buffer layout via the provided Wire array.
func (encoder *FwPacketEncoder) EncodeInto(value *FwPacket, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.Interest != nil {
		buf[pos] = byte(5)
		pos += 1
		pos += uint(enc.TLNum(encoder.Interest_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Interest_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.Interest_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.Interest_encoder.EncodeInto(value.Interest, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.Interest_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
	if value.Data != nil {
		buf[pos] = byte(6)
		pos += 1
		pos += uint(enc.TLNum(encoder.Data_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Data_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.Data_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.Data_encoder.EncodeInto(value.Data, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.Data_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
	if value.LpPacket != nil {
		buf[pos] = byte(100)
		pos += 1
		pos += uint(enc.TLNum(encoder.LpPacket_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.LpPacket_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.LpPacket_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.LpPacket_encoder.EncodeInto(value.LpPacket, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.LpPacket_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
}

// Encodes a ForwardingPacket (FwPacket) into a pre-allocated byte slice structure (enc.Wire) based on a predefined wire layout plan (wirePlan), returning the segmented byte arrays ready for serialization.
func (encoder *FwPacketEncoder) Encode(value *FwPacket) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a TLV-encoded NDN packet into a FwPacket containing Interest, Data, or LP packet components, handling critical fields based on the ignoreCritical flag.
func (context *FwPacketParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwPacket, error) {

	var handled_Interest bool = false
	var handled_Data bool = false
	var handled_LpPacket bool = false

	progress := -1
	_ = progress

	value := &FwPacket{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 5:
				if true {
					handled = true
					handled_Interest = true
					value.Interest, err = context.Interest_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 6:
				if true {
					handled = true
					handled_Data = true
					value.Data, err = context.Data_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 100:
				if true {
					handled = true
					handled_LpPacket = true
					value.LpPacket, err = context.LpPacket_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Interest && err == nil {
		value.Interest = nil
	}
	if !handled_Data && err == nil {
		value.Data = nil
	}
	if !handled_LpPacket && err == nil {
		value.LpPacket = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Serializes the FwPacket into its wire format using the FwPacketEncoder.
func (value *FwPacket) Encode() enc.Wire {
	encoder := FwPacketEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the serialized byte representation of the FwPacket by encoding its components and concatenating them into a single byte slice.
func (value *FwPacket) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded Forwarding Packet from the given WireView into a FwPacket struct, with optional suppression of critical parsing errors based on the ignoreCritical flag.
func ParseFwPacket(reader enc.WireView, ignoreCritical bool) (*FwPacket, error) {
	context := FwPacketParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwInterestEncoder struct {
	Length uint

	wirePlan []uint

	NameV_length uint

	ForwardingHintV_encoder FwLinksEncoder
}

type FwInterestParsingContext struct {
	ForwardingHintV_context FwLinksParsingContext
}

// Initializes the FwInterestEncoder with calculated total encoded length and wire plan based on the components and optional fields of the provided FwInterest.
func (encoder *FwInterestEncoder) Init(value *FwInterest) {
	if value.NameV != nil {
		encoder.NameV_length = 0
		for _, c := range value.NameV {
			encoder.NameV_length += uint(c.EncodingLength())
		}
	}

	if value.ForwardingHintV != nil {
		encoder.ForwardingHintV_encoder.Init(value.ForwardingHintV)
	}

	l := uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.CanBePrefixV {
		l += 1
		l += 1
	}
	if value.MustBeFreshV {
		l += 1
		l += 1
	}
	if value.ForwardingHintV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ForwardingHintV_encoder.Length).EncodingLength())
		l += encoder.ForwardingHintV_encoder.Length
	}
	if value.NonceV.IsSet() {
		l += 1
		l += 1 + 4
	}
	if optval, ok := value.InterestLifetimeV.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.HopLimitV != nil {
		l += 1
		l += 2
	}
	if value.ApplicationParameters {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.CanBePrefixV {
		l += 1
		l += 1
	}
	if value.MustBeFreshV {
		l += 1
		l += 1
	}
	if value.ForwardingHintV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ForwardingHintV_encoder.Length).EncodingLength())
		l += encoder.ForwardingHintV_encoder.Length
	}
	if value.NonceV.IsSet() {
		l += 1
		l += 1 + 4
	}
	if optval, ok := value.InterestLifetimeV.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.HopLimitV != nil {
		l += 1
		l += 2
	}
	if value.ApplicationParameters {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the ForwardingHint parsing context within the Interest parsing context to prepare for processing ForwardingHint components in NDN Interest packets.
func (context *FwInterestParsingContext) Init() {

	context.ForwardingHintV_context.Init()

}

// Encodes an FwInterest object into NDN TLV wire format by serializing its name components, optional fields (nonce, lifetime, hop limit), control flags (CanBePrefix, MustBeFresh), and nested structures (forwarding hints) into a byte buffer according to the NDN Interest packet specification.
func (encoder *FwInterestEncoder) EncodeInto(value *FwInterest, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.NameV != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NameV_length).EncodeInto(buf[pos:]))
		for _, c := range value.NameV {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.CanBePrefixV {
		buf[pos] = byte(33)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.MustBeFreshV {
		buf[pos] = byte(18)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.ForwardingHintV != nil {
		buf[pos] = byte(30)
		pos += 1
		pos += uint(enc.TLNum(encoder.ForwardingHintV_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.ForwardingHintV_encoder.Length > 0 {
			encoder.ForwardingHintV_encoder.EncodeInto(value.ForwardingHintV, buf[pos:])
			pos += encoder.ForwardingHintV_encoder.Length
		}
	}
	if optval, ok := value.NonceV.Get(); ok {
		buf[pos] = byte(10)
		pos += 1
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(optval))
		pos += 5
	}
	if optval, ok := value.InterestLifetimeV.Get(); ok {
		buf[pos] = byte(12)
		pos += 1

		buf[pos] = byte(enc.Nat(uint64(optval / time.Millisecond)).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.HopLimitV != nil {
		buf[pos] = byte(34)
		pos += 1
		buf[pos] = 1
		buf[pos+1] = byte(*value.HopLimitV)
		pos += 2
	}
	if value.ApplicationParameters {
		buf[pos] = byte(36)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureInfo {
		buf[pos] = byte(44)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureValue {
		buf[pos] = byte(46)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

// **Function Description:**  
Encodes an `FwInterest` into a wire format by allocating a pre-sized byte buffer according to the encoder's `wirePlan` and populating it with encoded data.
func (encoder *FwInterestEncoder) Encode(value *FwInterest) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a TLV-encoded NDN Interest packet into a structured FwInterest object, handling critical and non-critical fields according to the NDN specification and the ignoreCritical flag.
func (context *FwInterestParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwInterest, error) {

	var handled_NameV bool = false
	var handled_CanBePrefixV bool = false
	var handled_MustBeFreshV bool = false
	var handled_ForwardingHintV bool = false
	var handled_NonceV bool = false
	var handled_InterestLifetimeV bool = false
	var handled_HopLimitV bool = false
	var handled_ApplicationParameters bool = false
	var handled_SignatureInfo bool = false
	var handled_SignatureValue bool = false

	progress := -1
	_ = progress

	value := &FwInterest{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NameV = true
					delegate := reader.Delegate(int(l))
					value.NameV, err = delegate.ReadName()
				}
			case 33:
				if true {
					handled = true
					handled_CanBePrefixV = true
					value.CanBePrefixV = true
					err = reader.Skip(int(l))
				}
			case 18:
				if true {
					handled = true
					handled_MustBeFreshV = true
					value.MustBeFreshV = true
					err = reader.Skip(int(l))
				}
			case 30:
				if true {
					handled = true
					handled_ForwardingHintV = true
					value.ForwardingHintV, err = context.ForwardingHintV_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 10:
				if true {
					handled = true
					handled_NonceV = true
					{
						optval := uint32(0)
						optval = uint32(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint32(optval<<8) | uint32(x)
							}
						}
						value.NonceV.Set(optval)
					}
				}
			case 12:
				if true {
					handled = true
					handled_InterestLifetimeV = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						optval := time.Duration(timeInt) * time.Millisecond
						value.InterestLifetimeV.Set(optval)
					}
				}
			case 34:
				if true {
					handled = true
					handled_HopLimitV = true
					{
						buf, err := reader.ReadBuf(1)
						if err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						value.HopLimitV = &buf[0]
					}
				}
			case 36:
				if true {
					handled = true
					handled_ApplicationParameters = true
					value.ApplicationParameters = true
					err = reader.Skip(int(l))
				}
			case 44:
				if true {
					handled = true
					handled_SignatureInfo = true
					value.SignatureInfo = true
					err = reader.Skip(int(l))
				}
			case 46:
				if true {
					handled = true
					handled_SignatureValue = true
					value.SignatureValue = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NameV && err == nil {
		value.NameV = nil
	}
	if !handled_CanBePrefixV && err == nil {
		value.CanBePrefixV = false
	}
	if !handled_MustBeFreshV && err == nil {
		value.MustBeFreshV = false
	}
	if !handled_ForwardingHintV && err == nil {
		value.ForwardingHintV = nil
	}
	if !handled_NonceV && err == nil {
		value.NonceV.Unset()
	}
	if !handled_InterestLifetimeV && err == nil {
		value.InterestLifetimeV.Unset()
	}
	if !handled_HopLimitV && err == nil {
		value.HopLimitV = nil
	}
	if !handled_ApplicationParameters && err == nil {
		value.ApplicationParameters = false
	}
	if !handled_SignatureInfo && err == nil {
		value.SignatureInfo = false
	}
	if !handled_SignatureValue && err == nil {
		value.SignatureValue = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwInterest into its wire format representation for transmission.
func (value *FwInterest) Encode() enc.Wire {
	encoder := FwInterestEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte representation of the Interest packet by concatenating all encoded components.
func (value *FwInterest) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded Interest packet into an FwInterest object, optionally ignoring critical TLV elements that cannot be processed.
func ParseFwInterest(reader enc.WireView, ignoreCritical bool) (*FwInterest, error) {
	context := FwInterestParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwLinksEncoder struct {
	Length uint

	Names_subencoder []struct {
		Names_length uint
	}
}

type FwLinksParsingContext struct {
}

// Initializes the FwLinksEncoder by calculating and storing the total encoded length of name components in the FwLinks structure, including TLV overhead for each name element.
func (encoder *FwLinksEncoder) Init(value *FwLinks) {
	{
		Names_l := len(value.Names)
		encoder.Names_subencoder = make([]struct {
			Names_length uint
		}, Names_l)
		for i := 0; i < Names_l; i++ {
			pseudoEncoder := &encoder.Names_subencoder[i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: value.Names[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					encoder.Names_length = 0
					for _, c := range value.Names {
						encoder.Names_length += uint(c.EncodingLength())
					}
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Names_length).EncodingLength())
					l += encoder.Names_length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the parsing context for processing forwarder links configuration data.
func (context *FwLinksParsingContext) Init() {

}

// Encodes the `Names` field of an `FwLinks` structure into a binary buffer using a sequence of subencoders, writing each name component as a TLV-encoded field with type byte 0x07.
func (encoder *FwLinksEncoder) EncodeInto(value *FwLinks, buf []byte) {

	pos := uint(0)

	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					buf[pos] = byte(7)
					pos += 1
					pos += uint(enc.TLNum(encoder.Names_length).EncodeInto(buf[pos:]))
					for _, c := range value.Names {
						pos += uint(c.EncodeInto(buf[pos:]))
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes the provided FwLinks object into a wire-format byte slice using the encoder's predefined length.  

Example: Serializes the FwLinks structure into a binary wire representation for transmission or storage.
func (encoder *FwLinksEncoder) Encode(value *FwLinks) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded wire format data into a FwLinks structure, handling the 'Names' field (type 7) and processing/skipping other fields based on criticality and the ignoreCritical flag.
func (context *FwLinksParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwLinks, error) {

	var handled_Names bool = false

	progress := -1
	_ = progress

	value := &FwLinks{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Names = true
					if value.Names == nil {
						value.Names = make([]enc.Name, 0)
					}
					{
						pseudoValue := struct {
							Names enc.Name
						}{}
						{
							value := &pseudoValue
							delegate := reader.Delegate(int(l))
							value.Names, err = delegate.ReadName()
							_ = value
						}
						value.Names = append(value.Names, pseudoValue.Names)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Names && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwLinks object into a wire-format representation suitable for network transmission using the FwLinksEncoder.
func (value *FwLinks) Encode() enc.Wire {
	encoder := FwLinksEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the FwLinks value by encoding its components and concatenating them into a single byte slice.
func (value *FwLinks) Bytes() []byte {
	return value.Encode().Join()
}

// Parses wire-encoded FwLinks data into a FwLinks structure using the provided encoder, with an option to ignore critical parsing errors.
func ParseFwLinks(reader enc.WireView, ignoreCritical bool) (*FwLinks, error) {
	context := FwLinksParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwDataEncoder struct {
	Length uint

	wirePlan []uint

	NameV_length     uint
	MetaInfo_encoder FwMetaInfoEncoder
}

type FwDataParsingContext struct {
	MetaInfo_context FwMetaInfoParsingContext
}

// Initializes the encoder by calculating the total length of the encoded FwData object and preparing a wire plan based on the presence and lengths of its fields (NameV, MetaInfo, ContentV, SignatureInfo, and SignatureValue).
func (encoder *FwDataEncoder) Init(value *FwData) {
	if value.NameV != nil {
		encoder.NameV_length = 0
		for _, c := range value.NameV {
			encoder.NameV_length += uint(c.EncodingLength())
		}
	}
	if value.MetaInfo != nil {
		encoder.MetaInfo_encoder.Init(value.MetaInfo)
	}

	l := uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.MetaInfo != nil {
		l += 1
		l += uint(enc.TLNum(encoder.MetaInfo_encoder.Length).EncodingLength())
		l += encoder.MetaInfo_encoder.Length
	}
	if value.ContentV {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.MetaInfo != nil {
		l += 1
		l += uint(enc.TLNum(encoder.MetaInfo_encoder.Length).EncodingLength())
		l += encoder.MetaInfo_encoder.Length
	}
	if value.ContentV {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the internal MetaInfo context of the data parsing context, preparing it for subsequent data parsing operations.
func (context *FwDataParsingContext) Init() {

	context.MetaInfo_context.Init()

}

// Encodes a skeletal Data packet with Name and optional MetaInfo, including placeholder TLV elements for Content, SignatureInfo, and SignatureValue without their actual data.
func (encoder *FwDataEncoder) EncodeInto(value *FwData, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.NameV != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NameV_length).EncodeInto(buf[pos:]))
		for _, c := range value.NameV {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.MetaInfo != nil {
		buf[pos] = byte(20)
		pos += 1
		pos += uint(enc.TLNum(encoder.MetaInfo_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.MetaInfo_encoder.Length > 0 {
			encoder.MetaInfo_encoder.EncodeInto(value.MetaInfo, buf[pos:])
			pos += encoder.MetaInfo_encoder.Length
		}
	}
	if value.ContentV {
		buf[pos] = byte(21)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureInfo {
		buf[pos] = byte(22)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureValue {
		buf[pos] = byte(23)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

// Encodes a *FwData object into a wire format by allocating a pre-sized byte buffer according to the encoder's wire plan, splitting the buffer into segments, and populating each segment with encoded data fields.
func (encoder *FwDataEncoder) Encode(value *FwData) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a wire-encoded Data packet into an FwData structure, handling standard TLV fields like Name, MetaInfo, Content, and signatures, while skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *FwDataParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwData, error) {

	var handled_NameV bool = false
	var handled_MetaInfo bool = false
	var handled_ContentV bool = false
	var handled_SignatureInfo bool = false
	var handled_SignatureValue bool = false

	progress := -1
	_ = progress

	value := &FwData{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NameV = true
					delegate := reader.Delegate(int(l))
					value.NameV, err = delegate.ReadName()
				}
			case 20:
				if true {
					handled = true
					handled_MetaInfo = true
					value.MetaInfo, err = context.MetaInfo_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 21:
				if true {
					handled = true
					handled_ContentV = true
					value.ContentV = true
					err = reader.Skip(int(l))
				}
			case 22:
				if true {
					handled = true
					handled_SignatureInfo = true
					value.SignatureInfo = true
					err = reader.Skip(int(l))
				}
			case 23:
				if true {
					handled = true
					handled_SignatureValue = true
					value.SignatureValue = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NameV && err == nil {
		value.NameV = nil
	}
	if !handled_MetaInfo && err == nil {
		value.MetaInfo = nil
	}
	if !handled_ContentV && err == nil {
		value.ContentV = false
	}
	if !handled_SignatureInfo && err == nil {
		value.SignatureInfo = false
	}
	if !handled_SignatureValue && err == nil {
		value.SignatureValue = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwData structure into a wire-format representation using the FwDataEncoder.
func (value *FwData) Encode() enc.Wire {
	encoder := FwDataEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the FwData packet by encoding its contents and joining the resulting segments.
func (value *FwData) Bytes() []byte {
	return value.Encode().Join()
}

// Parses wire-encoded data into an FwData structure using a parsing context, with an option to ignore critical parsing errors.
func ParseFwData(reader enc.WireView, ignoreCritical bool) (*FwData, error) {
	context := FwDataParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwMetaInfoEncoder struct {
	Length uint
}

type FwMetaInfoParsingContext struct {
}

// Initializes the encoder's length based on the presence and encoding sizes of optional metadata fields (ContentType, FreshnessPeriod) and the FinalBlockID flag in the provided FwMetaInfo.
func (encoder *FwMetaInfoEncoder) Init(value *FwMetaInfo) {

	l := uint(0)
	if optval, ok := value.ContentType.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.FreshnessPeriod.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.FinalBlockID {
		l += 1
		l += 1
	}
	encoder.Length = l

}

// Initializes the parsing context for metadata associated with network data forwarding.
func (context *FwMetaInfoParsingContext) Init() {

}

// Serializes the MetaInfo fields (Content-Type, FreshnessPeriod, and FinalBlockID) of an NDN Data packet into a byte buffer using TLV encoding, appending each present field sequentially.
func (encoder *FwMetaInfoEncoder) EncodeInto(value *FwMetaInfo, buf []byte) {

	pos := uint(0)

	if optval, ok := value.ContentType.Get(); ok {
		buf[pos] = byte(24)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.FreshnessPeriod.Get(); ok {
		buf[pos] = byte(25)
		pos += 1

		buf[pos] = byte(enc.Nat(uint64(optval / time.Millisecond)).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.FinalBlockID {
		buf[pos] = byte(26)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

// Encodes the provided Forwarding Metadata Info into a wire format byte slice using the encoder's specified buffer size.
func (encoder *FwMetaInfoEncoder) Encode(value *FwMetaInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses TLV-encoded metadata into a `FwMetaInfo` structure, handling recognized fields (ContentType, FreshnessPeriod, FinalBlockID) and skipping or erroring on unknown critical fields based on the `ignoreCritical` flag.
func (context *FwMetaInfoParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwMetaInfo, error) {

	var handled_ContentType bool = false
	var handled_FreshnessPeriod bool = false
	var handled_FinalBlockID bool = false

	progress := -1
	_ = progress

	value := &FwMetaInfo{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 24:
				if true {
					handled = true
					handled_ContentType = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.ContentType.Set(optval)
					}
				}
			case 25:
				if true {
					handled = true
					handled_FreshnessPeriod = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						optval := time.Duration(timeInt) * time.Millisecond
						value.FreshnessPeriod.Set(optval)
					}
				}
			case 26:
				if true {
					handled = true
					handled_FinalBlockID = true
					value.FinalBlockID = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ContentType && err == nil {
		value.ContentType.Unset()
	}
	if !handled_FreshnessPeriod && err == nil {
		value.FreshnessPeriod.Unset()
	}
	if !handled_FinalBlockID && err == nil {
		value.FinalBlockID = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwMetaInfo struct into its wire representation using a dedicated encoder.
func (value *FwMetaInfo) Encode() enc.Wire {
	encoder := FwMetaInfoEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the FwMetaInfo by encoding its fields and joining the resulting components into a single byte slice.
func (value *FwMetaInfo) Bytes() []byte {
	return value.Encode().Join()
}

// Parses wire-encoded FwMetaInfo data into a FwMetaInfo object, optionally ignoring critical fields during parsing.
func ParseFwMetaInfo(reader enc.WireView, ignoreCritical bool) (*FwMetaInfo, error) {
	context := FwMetaInfoParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwLpPacketEncoder struct {
	Length uint

	wirePlan []uint

	Nack_encoder FwNetworkNackEncoder

	CachePolicy_encoder FwCachePolicyEncoder

	Fragment_length uint
}

type FwLpPacketParsingContext struct {
	Nack_context FwNetworkNackParsingContext

	CachePolicy_context FwCachePolicyParsingContext
}

// Initializes the FwLpPacketEncoder with the provided packet data, calculates the total encoded length by summing all field contributions, and constructs a wire encoding plan to guide the serialization of optional fields and fragments.
func (encoder *FwLpPacketEncoder) Init(value *FwLpPacket) {

	if value.Nack != nil {
		encoder.Nack_encoder.Init(value.Nack)
	}

	if value.CachePolicy != nil {
		encoder.CachePolicy_encoder.Init(value.CachePolicy)
	}

	if value.Fragment != nil {
		encoder.Fragment_length = 0
		for _, c := range value.Fragment {
			encoder.Fragment_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.Sequence.IsSet() {
		l += 1
		l += 1 + 8
	}
	if optval, ok := value.FragIndex.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.FragCount.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.PitToken != nil {
		l += 1
		l += uint(enc.TLNum(len(value.PitToken)).EncodingLength())
		l += uint(len(value.PitToken))
	}
	if value.Nack != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Nack_encoder.Length).EncodingLength())
		l += encoder.Nack_encoder.Length
	}
	if optval, ok := value.IncomingFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.NextHopFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.CachePolicy != nil {
		l += 3
		l += uint(enc.TLNum(encoder.CachePolicy_encoder.Length).EncodingLength())
		l += encoder.CachePolicy_encoder.Length
	}
	if optval, ok := value.CongestionMark.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Fragment != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Fragment_length).EncodingLength())
		l += encoder.Fragment_length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Sequence.IsSet() {
		l += 1
		l += 1 + 8
	}
	if optval, ok := value.FragIndex.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.FragCount.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.PitToken != nil {
		l += 1
		l += uint(enc.TLNum(len(value.PitToken)).EncodingLength())
		l += uint(len(value.PitToken))
	}
	if value.Nack != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Nack_encoder.Length).EncodingLength())
		l += encoder.Nack_encoder.Length
	}
	if optval, ok := value.IncomingFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.NextHopFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.CachePolicy != nil {
		l += 3
		l += uint(enc.TLNum(encoder.CachePolicy_encoder.Length).EncodingLength())
		l += encoder.CachePolicy_encoder.Length
	}
	if optval, ok := value.CongestionMark.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Fragment != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Fragment_length).EncodingLength())
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Fragment {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

// Initializes the NACK handling and cache policy sub-contexts within the packet parsing context to prepare for processing NDN packets.
func (context *FwLpPacketParsingContext) Init() {

	context.Nack_context.Init()

	context.CachePolicy_context.Init()

}

// Encodes a Forwarding Layer Packet (FW-LP) into a wire format using TLV (Type-Length-Value) encoding, serializing optional fields like sequence numbers, fragmentation metadata, Nack information, and payload fragments across one or more byte buffers.
func (encoder *FwLpPacketEncoder) EncodeInto(value *FwLpPacket, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if optval, ok := value.Sequence.Get(); ok {
		buf[pos] = byte(81)
		pos += 1
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(optval))
		pos += 9
	}
	if optval, ok := value.FragIndex.Get(); ok {
		buf[pos] = byte(82)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.FragCount.Get(); ok {
		buf[pos] = byte(83)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.PitToken != nil {
		buf[pos] = byte(98)
		pos += 1
		pos += uint(enc.TLNum(len(value.PitToken)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.PitToken)
		pos += uint(len(value.PitToken))
	}
	if value.Nack != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(800))
		pos += 3
		pos += uint(enc.TLNum(encoder.Nack_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Nack_encoder.Length > 0 {
			encoder.Nack_encoder.EncodeInto(value.Nack, buf[pos:])
			pos += encoder.Nack_encoder.Length
		}
	}
	if optval, ok := value.IncomingFaceId.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(812))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.NextHopFaceId.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(816))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.CachePolicy != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(820))
		pos += 3
		pos += uint(enc.TLNum(encoder.CachePolicy_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.CachePolicy_encoder.Length > 0 {
			encoder.CachePolicy_encoder.EncodeInto(value.CachePolicy, buf[pos:])
			pos += encoder.CachePolicy_encoder.Length
		}
	}
	if optval, ok := value.CongestionMark.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(832))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Fragment != nil {
		buf[pos] = byte(80)
		pos += 1
		pos += uint(enc.TLNum(encoder.Fragment_length).EncodeInto(buf[pos:]))
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Fragment {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
}

// Encodes a Forwarding Lp packet into a wire format by allocating precomputed byte slices according to the encoder's wire plan and populating them with packet data.
func (encoder *FwLpPacketEncoder) Encode(value *FwLpPacket) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

// Parses a binary wire-format LpPacket into an FwLpPacket structure by reading TLV-encoded fields, handling critical/non-critical options, and constructing corresponding fields while respecting the ignoreCritical flag for unrecognized critical fields.
func (context *FwLpPacketParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwLpPacket, error) {

	var handled_Sequence bool = false
	var handled_FragIndex bool = false
	var handled_FragCount bool = false
	var handled_PitToken bool = false
	var handled_Nack bool = false
	var handled_IncomingFaceId bool = false
	var handled_NextHopFaceId bool = false
	var handled_CachePolicy bool = false
	var handled_CongestionMark bool = false
	var handled_Fragment bool = false

	progress := -1
	_ = progress

	value := &FwLpPacket{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 81:
				if true {
					handled = true
					handled_Sequence = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Sequence.Set(optval)
					}
				}
			case 82:
				if true {
					handled = true
					handled_FragIndex = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.FragIndex.Set(optval)
					}
				}
			case 83:
				if true {
					handled = true
					handled_FragCount = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.FragCount.Set(optval)
					}
				}
			case 98:
				if true {
					handled = true
					handled_PitToken = true
					value.PitToken = make([]byte, l)
					_, err = reader.ReadFull(value.PitToken)
				}
			case 800:
				if true {
					handled = true
					handled_Nack = true
					value.Nack, err = context.Nack_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 812:
				if true {
					handled = true
					handled_IncomingFaceId = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.IncomingFaceId.Set(optval)
					}
				}
			case 816:
				if true {
					handled = true
					handled_NextHopFaceId = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.NextHopFaceId.Set(optval)
					}
				}
			case 820:
				if true {
					handled = true
					handled_CachePolicy = true
					value.CachePolicy, err = context.CachePolicy_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 832:
				if true {
					handled = true
					handled_CongestionMark = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.CongestionMark.Set(optval)
					}
				}
			case 80:
				if true {
					handled = true
					handled_Fragment = true
					value.Fragment, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Sequence && err == nil {
		value.Sequence.Unset()
	}
	if !handled_FragIndex && err == nil {
		value.FragIndex.Unset()
	}
	if !handled_FragCount && err == nil {
		value.FragCount.Unset()
	}
	if !handled_PitToken && err == nil {
		value.PitToken = nil
	}
	if !handled_Nack && err == nil {
		value.Nack = nil
	}
	if !handled_IncomingFaceId && err == nil {
		value.IncomingFaceId.Unset()
	}
	if !handled_NextHopFaceId && err == nil {
		value.NextHopFaceId.Unset()
	}
	if !handled_CachePolicy && err == nil {
		value.CachePolicy = nil
	}
	if !handled_CongestionMark && err == nil {
		value.CongestionMark.Unset()
	}
	if !handled_Fragment && err == nil {
		value.Fragment = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwLpPacket into a wire format using the FwLpPacketEncoder.
func (value *FwLpPacket) Encode() enc.Wire {
	encoder := FwLpPacketEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the packet by encoding its components and joining them into a single slice.
func (value *FwLpPacket) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a Forwarding Lp packet from wire format data, optionally ignoring critical elements.
func ParseFwLpPacket(reader enc.WireView, ignoreCritical bool) (*FwLpPacket, error) {
	context := FwLpPacketParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwNetworkNackEncoder struct {
	Length uint
}

type FwNetworkNackParsingContext struct {
}

// Initializes the encoder's total length by calculating the combined size of fixed overhead (3 bytes) and variable-length encoded Nack reason (1 byte header plus natural encoding length).  

**Explanation**:  
- `l += 3` accounts for fixed fields (e.g., TLV type + fixed-value fields).  
- `enc.Nat(value.Reason).EncodingLength()` computes variable-length encoding (e.g., non-zero compact encoding for the Nack reason).  
- The result sets `encoder.Length`, enabling downstream serialization with the correct buffer size.
func (encoder *FwNetworkNackEncoder) Init(value *FwNetworkNack) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.Reason).EncodingLength())
	encoder.Length = l

}

// Initializes the forwarder's network NACK parsing context for processing incoming NACK packets in a Named Data Networking (NDN) system.
func (context *FwNetworkNackParsingContext) Init() {

}

// Encodes a FwNetworkNack message into the provided byte buffer, starting with a fixed TLV type (253) and a 16-bit code (801), followed by the encoded reason field using a length-prefixed format.
func (encoder *FwNetworkNackEncoder) EncodeInto(value *FwNetworkNack, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(801))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Reason).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Serializes a `FwNetworkNack` into a wire-encoded byte slice using the encoder's defined length for network transmission.
func (encoder *FwNetworkNackEncoder) Encode(value *FwNetworkNack) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded NACK packet into a FwNetworkNack structure, handling the required Reason field (type 801) and skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *FwNetworkNackParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwNetworkNack, error) {

	var handled_Reason bool = false

	progress := -1
	_ = progress

	value := &FwNetworkNack{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 801:
				if true {
					handled = true
					handled_Reason = true
					value.Reason = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Reason = uint64(value.Reason<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Reason && err == nil {
		err = enc.ErrSkipRequired{Name: "Reason", TypeNum: 801}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwNetworkNack object into a serialized wire format for network transmission.
func (value *FwNetworkNack) Encode() enc.Wire {
	encoder := FwNetworkNackEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the wire-encoded byte representation of the NetworkNACK.
func (value *FwNetworkNack) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a NACK packet from a wire format reader into a FwNetworkNack object, using a parsing context and optionally ignoring critical errors.
func ParseFwNetworkNack(reader enc.WireView, ignoreCritical bool) (*FwNetworkNack, error) {
	context := FwNetworkNackParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwCachePolicyEncoder struct {
	Length uint
}

type FwCachePolicyParsingContext struct {
}

// Calculates and sets the total encoded length of the FwCachePolicy by summing a fixed overhead of 3 bytes and the variable-length TLV encoding of the CachePolicyType field.
func (encoder *FwCachePolicyEncoder) Init(value *FwCachePolicy) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.CachePolicyType).EncodingLength())
	encoder.Length = l

}

// Initializes the FwCachePolicyParsingContext, but does not perform any actions.
func (context *FwCachePolicyParsingContext) Init() {

}

// Encodes a Forwarding Cache Policy (FwCachePolicy) into a binary TLV format in the provided buffer, starting with a fixed type-value pair (253:821) followed by the encoded cache policy type.
func (encoder *FwCachePolicyEncoder) EncodeInto(value *FwCachePolicy, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(821))
	pos += 3

	buf[pos] = byte(enc.Nat(value.CachePolicyType).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Serializes the given FwCachePolicy into a wire-encoded byte slice using the encoder's precomputed length.
func (encoder *FwCachePolicyEncoder) Encode(value *FwCachePolicy) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary wire format representation into an FwCachePolicy structure, handling the required CachePolicyType field (type 821) and skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *FwCachePolicyParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwCachePolicy, error) {

	var handled_CachePolicyType bool = false

	progress := -1
	_ = progress

	value := &FwCachePolicy{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 821:
				if true {
					handled = true
					handled_CachePolicyType = true
					value.CachePolicyType = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.CachePolicyType = uint64(value.CachePolicyType<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_CachePolicyType && err == nil {
		err = enc.ErrSkipRequired{Name: "CachePolicyType", TypeNum: 821}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the FwCachePolicy into a wire format representation for transmission or storage.
func (value *FwCachePolicy) Encode() enc.Wire {
	encoder := FwCachePolicyEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte representation of the forwarder cache policy by encoding and joining its components.
func (value *FwCachePolicy) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a Forwarding Cache Policy from a wire-encoded format, optionally ignoring critical unrecognized fields.
func ParseFwCachePolicy(reader enc.WireView, ignoreCritical bool) (*FwCachePolicy, error) {
	context := FwCachePolicyParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
