// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
	spec "github.com/named-data/ndnd/std/ndn/spec_2022"
)

type RepoCmdEncoder struct {
	Length uint

	SyncJoin_encoder  SyncJoinEncoder
	BlobFetch_encoder BlobFetchEncoder
}

type RepoCmdParsingContext struct {
	SyncJoin_context  SyncJoinParsingContext
	BlobFetch_context BlobFetchParsingContext
}

// Initializes the encoder with the provided RepoCmd value, setting up sub-encoders for SyncJoin and BlobFetch if present, and calculates the total encoded length by summing fixed overhead, length metadata, and payload sizes for each field.
func (encoder *RepoCmdEncoder) Init(value *RepoCmd) {
	if value.SyncJoin != nil {
		encoder.SyncJoin_encoder.Init(value.SyncJoin)
	}
	if value.BlobFetch != nil {
		encoder.BlobFetch_encoder.Init(value.BlobFetch)
	}

	l := uint(0)
	if value.SyncJoin != nil {
		l += 3
		l += uint(enc.TLNum(encoder.SyncJoin_encoder.Length).EncodingLength())
		l += encoder.SyncJoin_encoder.Length
	}
	if value.BlobFetch != nil {
		l += 3
		l += uint(enc.TLNum(encoder.BlobFetch_encoder.Length).EncodingLength())
		l += encoder.BlobFetch_encoder.Length
	}
	encoder.Length = l

}

// Initializes the SyncJoin and BlobFetch sub-contexts within the RepoCmdParsingContext.
func (context *RepoCmdParsingContext) Init() {
	context.SyncJoin_context.Init()
	context.BlobFetch_context.Init()
}

// Encodes a RepoCmd object into a binary buffer using TLV (Type-Length-Value) format, handling SyncJoin and BlobFetch commands with specific type numbers (7600 and 7602) by serializing their encoded lengths and values sequentially.
func (encoder *RepoCmdEncoder) EncodeInto(value *RepoCmd, buf []byte) {

	pos := uint(0)

	if value.SyncJoin != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(7600))
		pos += 3
		pos += uint(enc.TLNum(encoder.SyncJoin_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.SyncJoin_encoder.Length > 0 {
			encoder.SyncJoin_encoder.EncodeInto(value.SyncJoin, buf[pos:])
			pos += encoder.SyncJoin_encoder.Length
		}
	}
	if value.BlobFetch != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(7602))
		pos += 3
		pos += uint(enc.TLNum(encoder.BlobFetch_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.BlobFetch_encoder.Length > 0 {
			encoder.BlobFetch_encoder.EncodeInto(value.BlobFetch, buf[pos:])
			pos += encoder.BlobFetch_encoder.Length
		}
	}
}

// Encodes a RepoCmd into a binary wire format using the encoder's predefined length, returning a slice containing the serialized byte data.
func (encoder *RepoCmdEncoder) Encode(value *RepoCmd) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded RepoCmd, extracting SyncJoin and BlobFetch sub-structures while handling unknown fields according to the ignoreCritical flag.
func (context *RepoCmdParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*RepoCmd, error) {

	var handled_SyncJoin bool = false
	var handled_BlobFetch bool = false

	progress := -1
	_ = progress

	value := &RepoCmd{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7600:
				if true {
					handled = true
					handled_SyncJoin = true
					value.SyncJoin, err = context.SyncJoin_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 7602:
				if true {
					handled = true
					handled_BlobFetch = true
					value.BlobFetch, err = context.BlobFetch_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_SyncJoin && err == nil {
		value.SyncJoin = nil
	}
	if !handled_BlobFetch && err == nil {
		value.BlobFetch = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the repository command into a wire format for transmission or storage using the associated encoder.
func (value *RepoCmd) Encode() enc.Wire {
	encoder := RepoCmdEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// **Description:**  
Serializes the RepoCmd into a byte slice by encoding and joining its components.
func (value *RepoCmd) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-format representation of a repository command into a RepoCmd object, using a parsing context and optionally ignoring critical fields if specified.
func ParseRepoCmd(reader enc.WireView, ignoreCritical bool) (*RepoCmd, error) {
	context := RepoCmdParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type RepoCmdResEncoder struct {
	Length uint
}

type RepoCmdResParsingContext struct {
}

// Calculates the total encoded length of a RepoCmdRes message (including TLV overhead for status and message fields) and sets it on the encoder.
func (encoder *RepoCmdResEncoder) Init(value *RepoCmdRes) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.Status).EncodingLength())
	l += 3
	l += uint(enc.TLNum(len(value.Message)).EncodingLength())
	l += uint(len(value.Message))
	encoder.Length = l

}

// Initializes the repository command response parsing context, preparing it for processing command responses.
func (context *RepoCmdResParsingContext) Init() {

}

// Encodes a RepoCmdRes object into a binary TLV format in the provided buffer, including a status code (TLV type 657) and an optional message (TLV type 658).
func (encoder *RepoCmdResEncoder) EncodeInto(value *RepoCmdRes, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(657))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Status).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(658))
	pos += 3
	pos += uint(enc.TLNum(len(value.Message)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Message)
	pos += uint(len(value.Message))
}

// Encodes a RepoCmdRes object into a pre-allocated byte buffer of the encoder's specified length and returns it as a single-element enc.Wire slice.
func (encoder *RepoCmdResEncoder) Encode(value *RepoCmdRes) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded RepoCmdRes from a binary wire format, extracting required Status and Message fields, and handling unrecognized or critical fields based on the ignoreCritical flag.
func (context *RepoCmdResParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*RepoCmdRes, error) {

	var handled_Status bool = false
	var handled_Message bool = false

	progress := -1
	_ = progress

	value := &RepoCmdRes{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 657:
				if true {
					handled = true
					handled_Status = true
					value.Status = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Status = uint64(value.Status<<8) | uint64(x)
						}
					}
				}
			case 658:
				if true {
					handled = true
					handled_Message = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Message = builder.String()
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Status && err == nil {
		err = enc.ErrSkipRequired{Name: "Status", TypeNum: 657}
	}
	if !handled_Message && err == nil {
		err = enc.ErrSkipRequired{Name: "Message", TypeNum: 658}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the RepoCmdRes object into a wire format using a dedicated encoder for serialization or network transmission.
func (value *RepoCmdRes) Encode() enc.Wire {
	encoder := RepoCmdResEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the RepoCmdRes value into its wire format and joins the resulting segments into a single byte slice.
func (value *RepoCmdRes) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a RepoCmdRes structure from encoded wire data, using a parsing context and an option to ignore critical errors during decoding.
func ParseRepoCmdRes(reader enc.WireView, ignoreCritical bool) (*RepoCmdRes, error) {
	context := RepoCmdResParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type SyncJoinEncoder struct {
	Length uint

	Protocol_encoder        spec.NameContainerEncoder
	Group_encoder           spec.NameContainerEncoder
	MulticastPrefix_encoder spec.NameContainerEncoder
	HistorySnapshot_encoder HistorySnapshotConfigEncoder
}

type SyncJoinParsingContext struct {
	Protocol_context        spec.NameContainerParsingContext
	Group_context           spec.NameContainerParsingContext
	MulticastPrefix_context spec.NameContainerParsingContext
	HistorySnapshot_context HistorySnapshotConfigParsingContext
}

// Initializes the SyncJoinEncoder with the provided SyncJoin value, setting up sub-encoders for non-nil fields and calculating the total encoded length including TLV type/length overhead for each field.
func (encoder *SyncJoinEncoder) Init(value *SyncJoin) {
	if value.Protocol != nil {
		encoder.Protocol_encoder.Init(value.Protocol)
	}
	if value.Group != nil {
		encoder.Group_encoder.Init(value.Group)
	}
	if value.MulticastPrefix != nil {
		encoder.MulticastPrefix_encoder.Init(value.MulticastPrefix)
	}
	if value.HistorySnapshot != nil {
		encoder.HistorySnapshot_encoder.Init(value.HistorySnapshot)
	}

	l := uint(0)
	if value.Protocol != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Protocol_encoder.Length).EncodingLength())
		l += encoder.Protocol_encoder.Length
	}
	if value.Group != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Group_encoder.Length).EncodingLength())
		l += encoder.Group_encoder.Length
	}
	if value.MulticastPrefix != nil {
		l += 3
		l += uint(enc.TLNum(encoder.MulticastPrefix_encoder.Length).EncodingLength())
		l += encoder.MulticastPrefix_encoder.Length
	}
	if value.HistorySnapshot != nil {
		l += 3
		l += uint(enc.TLNum(encoder.HistorySnapshot_encoder.Length).EncodingLength())
		l += encoder.HistorySnapshot_encoder.Length
	}
	encoder.Length = l

}

// Initializes the SyncJoinParsingContext by initializing its protocol, group, multicast prefix, and history snapshot sub-contexts.
func (context *SyncJoinParsingContext) Init() {
	context.Protocol_context.Init()
	context.Group_context.Init()
	context.MulticastPrefix_context.Init()
	context.HistorySnapshot_context.Init()
}

// Encodes a SyncJoin object into a TLV (Type-Length-Value)-formatted byte slice, writing non-nil fields (Protocol, Group, MulticastPrefix, HistorySnapshot) with their respective type codes and encoded values into the provided buffer.
func (encoder *SyncJoinEncoder) EncodeInto(value *SyncJoin, buf []byte) {

	pos := uint(0)

	if value.Protocol != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(401))
		pos += 3
		pos += uint(enc.TLNum(encoder.Protocol_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Protocol_encoder.Length > 0 {
			encoder.Protocol_encoder.EncodeInto(value.Protocol, buf[pos:])
			pos += encoder.Protocol_encoder.Length
		}
	}
	if value.Group != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(403))
		pos += 3
		pos += uint(enc.TLNum(encoder.Group_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Group_encoder.Length > 0 {
			encoder.Group_encoder.EncodeInto(value.Group, buf[pos:])
			pos += encoder.Group_encoder.Length
		}
	}
	if value.MulticastPrefix != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(404))
		pos += 3
		pos += uint(enc.TLNum(encoder.MulticastPrefix_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.MulticastPrefix_encoder.Length > 0 {
			encoder.MulticastPrefix_encoder.EncodeInto(value.MulticastPrefix, buf[pos:])
			pos += encoder.MulticastPrefix_encoder.Length
		}
	}
	if value.HistorySnapshot != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(420))
		pos += 3
		pos += uint(enc.TLNum(encoder.HistorySnapshot_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.HistorySnapshot_encoder.Length > 0 {
			encoder.HistorySnapshot_encoder.EncodeInto(value.HistorySnapshot, buf[pos:])
			pos += encoder.HistorySnapshot_encoder.Length
		}
	}
}

// Encodes a SyncJoin object into a byte slice of the encoder's specified length and returns it as a Wire.
func (encoder *SyncJoinEncoder) Encode(value *SyncJoin) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a SyncJoin object from a TLV-encoded wire format using the provided parsing contexts, handling critical and non-critical fields according to the ignoreCritical flag.
func (context *SyncJoinParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*SyncJoin, error) {

	var handled_Protocol bool = false
	var handled_Group bool = false
	var handled_MulticastPrefix bool = false
	var handled_HistorySnapshot bool = false

	progress := -1
	_ = progress

	value := &SyncJoin{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 401:
				if true {
					handled = true
					handled_Protocol = true
					value.Protocol, err = context.Protocol_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 403:
				if true {
					handled = true
					handled_Group = true
					value.Group, err = context.Group_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 404:
				if true {
					handled = true
					handled_MulticastPrefix = true
					value.MulticastPrefix, err = context.MulticastPrefix_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 420:
				if true {
					handled = true
					handled_HistorySnapshot = true
					value.HistorySnapshot, err = context.HistorySnapshot_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Protocol && err == nil {
		value.Protocol = nil
	}
	if !handled_Group && err == nil {
		value.Group = nil
	}
	if !handled_MulticastPrefix && err == nil {
		value.MulticastPrefix = nil
	}
	if !handled_HistorySnapshot && err == nil {
		value.HistorySnapshot = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the SyncJoin value into a wire format using a SyncJoinEncoder for serialization.
func (value *SyncJoin) Encode() enc.Wire {
	encoder := SyncJoinEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the SyncJoin value and returns its joined byte representation.
func (value *SyncJoin) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a SyncJoin message from encoded data using a parsing context and specified critical field handling.
func ParseSyncJoin(reader enc.WireView, ignoreCritical bool) (*SyncJoin, error) {
	context := SyncJoinParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type HistorySnapshotConfigEncoder struct {
	Length uint
}

type HistorySnapshotConfigParsingContext struct {
}

// Initializes the encoder by calculating the total encoded length of the HistorySnapshotConfig, combining a fixed 3-byte overhead with the variable-length encoding of the Threshold field (1 byte for type plus the size needed to encode the threshold value as a natural number).
func (encoder *HistorySnapshotConfigEncoder) Init(value *HistorySnapshotConfig) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.Threshold).EncodingLength())
	encoder.Length = l

}

// Initializes the HistorySnapshotConfigParsingContext, preparing it for parsing configuration data.
func (context *HistorySnapshotConfigParsingContext) Init() {

}

// Encodes a HistorySnapshotConfig into a binary buffer using a TLV-like format, writing a fixed type (253) and length (421) header followed by the Threshold field encoded as a variable-length natural number.
func (encoder *HistorySnapshotConfigEncoder) EncodeInto(value *HistorySnapshotConfig, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(421))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Threshold).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes a HistorySnapshotConfig into a wire-format byte slice using the encoder's precomputed length to allocate the buffer.
func (encoder *HistorySnapshotConfigEncoder) Encode(value *HistorySnapshotConfig) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded HistorySnapshotConfig, extracting the required Threshold field (type 421) and handling critical/unrecognized fields according to the ignoreCritical flag.
func (context *HistorySnapshotConfigParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*HistorySnapshotConfig, error) {

	var handled_Threshold bool = false

	progress := -1
	_ = progress

	value := &HistorySnapshotConfig{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 421:
				if true {
					handled = true
					handled_Threshold = true
					value.Threshold = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Threshold = uint64(value.Threshold<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Threshold && err == nil {
		err = enc.ErrSkipRequired{Name: "Threshold", TypeNum: 421}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the HistorySnapshotConfig into its wire format representation using a dedicated encoder.
func (value *HistorySnapshotConfig) Encode() enc.Wire {
	encoder := HistorySnapshotConfigEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Encodes the HistorySnapshotConfig into a byte slice by joining its encoded components.
func (value *HistorySnapshotConfig) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a HistorySnapshotConfig from the provided wire format reader, with an option to ignore critical parsing errors.
func ParseHistorySnapshotConfig(reader enc.WireView, ignoreCritical bool) (*HistorySnapshotConfig, error) {
	context := HistorySnapshotConfigParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type BlobFetchEncoder struct {
	Length uint

	Name_encoder    spec.NameContainerEncoder
	Data_subencoder []struct {
	}
}

type BlobFetchParsingContext struct {
	Name_context spec.NameContainerParsingContext
}

// Initializes the BlobFetchEncoder with the provided BlobFetch's name and byte slice data, calculating the total encoded length by summing TLV header overhead, length field sizes, and payload lengths for each component.
func (encoder *BlobFetchEncoder) Init(value *BlobFetch) {
	if value.Name != nil {
		encoder.Name_encoder.Init(value.Name)
	}
	{
		Data_l := len(value.Data)
		encoder.Data_subencoder = make([]struct {
		}, Data_l)
		for i := 0; i < Data_l; i++ {
			pseudoEncoder := &encoder.Data_subencoder[i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: value.Data[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Name_encoder.Length).EncodingLength())
		l += encoder.Name_encoder.Length
	}
	if value.Data != nil {
		for seq_i, seq_v := range value.Data {
			pseudoEncoder := &encoder.Data_subencoder[seq_i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Data != nil {
					l += 3
					l += uint(enc.TLNum(len(value.Data)).EncodingLength())
					l += uint(len(value.Data))
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the `Name_context` field of the `BlobFetchParsingContext`, preparing it for parsing operations.
func (context *BlobFetchParsingContext) Init() {
	context.Name_context.Init()

}

// Encodes a BlobFetch object into a TLV-based wire format, writing the Name as a type-440 TLV element and each Data slice entry as a type-442 TLV element into the provided buffer.
func (encoder *BlobFetchEncoder) EncodeInto(value *BlobFetch, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(440))
		pos += 3
		pos += uint(enc.TLNum(encoder.Name_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Name_encoder.Length > 0 {
			encoder.Name_encoder.EncodeInto(value.Name, buf[pos:])
			pos += encoder.Name_encoder.Length
		}
	}
	if value.Data != nil {
		for seq_i, seq_v := range value.Data {
			pseudoEncoder := &encoder.Data_subencoder[seq_i]
			pseudoValue := struct {
				Data []byte
			}{
				Data: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Data != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(442))
					pos += 3
					pos += uint(enc.TLNum(len(value.Data)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.Data)
					pos += uint(len(value.Data))
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a BlobFetch value into a byte slice using the encoder's specified length, returning it as a wire-format structure.
func (encoder *BlobFetchEncoder) Encode(value *BlobFetch) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded BlobFetch object from a WireView reader, extracting Name components via a nested context and collecting raw Data bytes while handling critical/unrecognized fields according to the ignoreCritical flag.
func (context *BlobFetchParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*BlobFetch, error) {

	var handled_Name bool = false
	var handled_Data bool = false

	progress := -1
	_ = progress

	value := &BlobFetch{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 440:
				if true {
					handled = true
					handled_Name = true
					value.Name, err = context.Name_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 442:
				if true {
					handled = true
					handled_Data = true
					if value.Data == nil {
						value.Data = make([][]byte, 0)
					}
					{
						pseudoValue := struct {
							Data []byte
						}{}
						{
							value := &pseudoValue
							value.Data = make([]byte, l)
							_, err = reader.ReadFull(value.Data)
							_ = value
						}
						value.Data = append(value.Data, pseudoValue.Data)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_Data && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the BlobFetch value into its wire representation for network transmission or persistence.
func (value *BlobFetch) Encode() enc.Wire {
	encoder := BlobFetchEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded bytes of the BlobFetch as a single byte slice by concatenating its encoded components.
func (value *BlobFetch) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a BlobFetch structure from encoded NDN data using a parsing context, with an option to ignore critical fields if specified.
func ParseBlobFetch(reader enc.WireView, ignoreCritical bool) (*BlobFetch, error) {
	context := BlobFetchParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
