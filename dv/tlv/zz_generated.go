// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type PacketEncoder struct {
	Length uint

	Advertisement_encoder AdvertisementEncoder
	PrefixOpList_encoder  PrefixOpListEncoder
}

type PacketParsingContext struct {
	Advertisement_context AdvertisementParsingContext
	PrefixOpList_context  PrefixOpListParsingContext
}

// Initializes the packet's Advertisement and PrefixOpList encoders and calculates the total encoded length of the packet by summing the TLV header sizes and encoded lengths of each component.
func (encoder *PacketEncoder) Init(value *Packet) {
	if value.Advertisement != nil {
		encoder.Advertisement_encoder.Init(value.Advertisement)
	}
	if value.PrefixOpList != nil {
		encoder.PrefixOpList_encoder.Init(value.PrefixOpList)
	}

	l := uint(0)
	if value.Advertisement != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Advertisement_encoder.Length).EncodingLength())
		l += encoder.Advertisement_encoder.Length
	}
	if value.PrefixOpList != nil {
		l += 3
		l += uint(enc.TLNum(encoder.PrefixOpList_encoder.Length).EncodingLength())
		l += encoder.PrefixOpList_encoder.Length
	}
	encoder.Length = l

}

// Initializes the Advertisement and PrefixOpList contexts within the PacketParsingContext.
func (context *PacketParsingContext) Init() {
	context.Advertisement_context.Init()
	context.PrefixOpList_context.Init()
}

// Encodes a Packet structure into a byte buffer using TLV (Type-Length-Value) format, serializing non-nil fields like Advertisement (type 201) and PrefixOpList (type 301) with their respective type identifiers and lengths.
func (encoder *PacketEncoder) EncodeInto(value *Packet, buf []byte) {

	pos := uint(0)

	if value.Advertisement != nil {
		buf[pos] = byte(201)
		pos += 1
		pos += uint(enc.TLNum(encoder.Advertisement_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Advertisement_encoder.Length > 0 {
			encoder.Advertisement_encoder.EncodeInto(value.Advertisement, buf[pos:])
			pos += encoder.Advertisement_encoder.Length
		}
	}
	if value.PrefixOpList != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(301))
		pos += 3
		pos += uint(enc.TLNum(encoder.PrefixOpList_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.PrefixOpList_encoder.Length > 0 {
			encoder.PrefixOpList_encoder.EncodeInto(value.PrefixOpList, buf[pos:])
			pos += encoder.PrefixOpList_encoder.Length
		}
	}
}

// Encodes the provided Packet into a byte slice of the pre-determined length specified by the encoder and returns it wrapped in a Wire structure.
func (encoder *PacketEncoder) Encode(value *Packet) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded packet into a Packet structure, handling Advertisement (type 201) and PrefixOpList (type 301) components while skipping or rejecting unrecognized critical fields based on the ignoreCritical flag.
func (context *PacketParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Packet, error) {

	var handled_Advertisement bool = false
	var handled_PrefixOpList bool = false

	progress := -1
	_ = progress

	value := &Packet{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 201:
				if true {
					handled = true
					handled_Advertisement = true
					value.Advertisement, err = context.Advertisement_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 301:
				if true {
					handled = true
					handled_PrefixOpList = true
					value.PrefixOpList, err = context.PrefixOpList_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Advertisement && err == nil {
		value.Advertisement = nil
	}
	if !handled_PrefixOpList && err == nil {
		value.PrefixOpList = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the packet into its wire format representation.
func (value *Packet) Encode() enc.Wire {
	encoder := PacketEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte representation of the packet.
func (value *Packet) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a binary-encoded NDN packet from the provided `WireView` reader, constructing a `Packet` object and optionally ignoring critical TLV elements if `ignoreCritical` is true.
func ParsePacket(reader enc.WireView, ignoreCritical bool) (*Packet, error) {
	context := PacketParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type AdvertisementEncoder struct {
	Length uint

	Entries_subencoder []struct {
		Entries_encoder AdvEntryEncoder
	}
}

type AdvertisementParsingContext struct {
	Entries_context AdvEntryParsingContext
}

// Initializes the AdvertisementEncoder with the provided Advertisement, setting up sub-encoders for each entry and calculating the total encoded length required for TLV-encoded serialization.
func (encoder *AdvertisementEncoder) Init(value *Advertisement) {
	{
		Entries_l := len(value.Entries)
		encoder.Entries_subencoder = make([]struct {
			Entries_encoder AdvEntryEncoder
		}, Entries_l)
		for i := 0; i < Entries_l; i++ {
			pseudoEncoder := &encoder.Entries_subencoder[i]
			pseudoValue := struct {
				Entries *AdvEntry
			}{
				Entries: value.Entries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					encoder.Entries_encoder.Init(value.Entries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *AdvEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Entries_encoder.Length).EncodingLength())
					l += encoder.Entries_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes the advertisement parsing context by initializing its internal entries context.
func (context *AdvertisementParsingContext) Init() {
	context.Entries_context.Init()
}

// Encodes the entries of an Advertisement into a binary TLV format in the provided buffer, using type code 202 for each entry with its corresponding sub-encoder.
func (encoder *AdvertisementEncoder) EncodeInto(value *Advertisement, buf []byte) {

	pos := uint(0)

	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *AdvEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					buf[pos] = byte(202)
					pos += 1
					pos += uint(enc.TLNum(encoder.Entries_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Entries_encoder.Length > 0 {
						encoder.Entries_encoder.EncodeInto(value.Entries, buf[pos:])
						pos += encoder.Entries_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes an Advertisement into a wire-format TLV block as a single byte slice for transmission.
func (encoder *AdvertisementEncoder) Encode(value *Advertisement) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary-encoded Advertisement from a wire format reader, extracting entries and handling critical/unrecognized fields according to the ignoreCritical flag.
func (context *AdvertisementParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Advertisement, error) {

	var handled_Entries bool = false

	progress := -1
	_ = progress

	value := &Advertisement{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 202:
				if true {
					handled = true
					handled_Entries = true
					if value.Entries == nil {
						value.Entries = make([]*AdvEntry, 0)
					}
					{
						pseudoValue := struct {
							Entries *AdvEntry
						}{}
						{
							value := &pseudoValue
							value.Entries, err = context.Entries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Entries = append(value.Entries, pseudoValue.Entries)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Entries && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the Advertisement into its wire format representation using an AdvertisementEncoder.
func (value *Advertisement) Encode() enc.Wire {
	encoder := AdvertisementEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte slice representation of the Advertisement by encoding and concatenating its components.
func (value *Advertisement) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a TLV-encoded Advertisement from the provided wire format reader, optionally ignoring unknown critical elements.
func ParseAdvertisement(reader enc.WireView, ignoreCritical bool) (*Advertisement, error) {
	context := AdvertisementParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type AdvEntryEncoder struct {
	Length uint

	Destination_encoder DestinationEncoder
	NextHop_encoder     DestinationEncoder
}

type AdvEntryParsingContext struct {
	Destination_context DestinationParsingContext
	NextHop_context     DestinationParsingContext
}

// Initializes the encoder with the provided AdvEntry and calculates the total encoded length, including optional fields (Destination, NextHop) and their TLV encoding overhead.
func (encoder *AdvEntryEncoder) Init(value *AdvEntry) {
	if value.Destination != nil {
		encoder.Destination_encoder.Init(value.Destination)
	}
	if value.NextHop != nil {
		encoder.NextHop_encoder.Init(value.NextHop)
	}

	l := uint(0)
	if value.Destination != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Destination_encoder.Length).EncodingLength())
		l += encoder.Destination_encoder.Length
	}
	if value.NextHop != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NextHop_encoder.Length).EncodingLength())
		l += encoder.NextHop_encoder.Length
	}
	l += 1
	l += uint(1 + enc.Nat(value.Cost).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.OtherCost).EncodingLength())
	encoder.Length = l

}

// Initializes the destination and next hop parsing contexts within the AdvEntryParsingContext, preparing them for data parsing operations.
func (context *AdvEntryParsingContext) Init() {
	context.Destination_context.Init()
	context.NextHop_context.Init()

}

// Encodes an AdvEntry object into a TLV (Type-Length-Value)-formatted binary buffer, serializing its Destination, NextHop, Cost, and OtherCost fields according to the specified encoders.
func (encoder *AdvEntryEncoder) EncodeInto(value *AdvEntry, buf []byte) {

	pos := uint(0)

	if value.Destination != nil {
		buf[pos] = byte(204)
		pos += 1
		pos += uint(enc.TLNum(encoder.Destination_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Destination_encoder.Length > 0 {
			encoder.Destination_encoder.EncodeInto(value.Destination, buf[pos:])
			pos += encoder.Destination_encoder.Length
		}
	}
	if value.NextHop != nil {
		buf[pos] = byte(206)
		pos += 1
		pos += uint(enc.TLNum(encoder.NextHop_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.NextHop_encoder.Length > 0 {
			encoder.NextHop_encoder.EncodeInto(value.NextHop, buf[pos:])
			pos += encoder.NextHop_encoder.Length
		}
	}
	buf[pos] = byte(208)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Cost).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(210)
	pos += 1

	buf[pos] = byte(enc.Nat(value.OtherCost).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes an AdvEntry into a byte slice using the AdvEntryEncoder's specified length and returns it as a Wire (a slice containing a single byte slice).
func (encoder *AdvEntryEncoder) Encode(value *AdvEntry) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary-encoded Advertisement Entry (AdvEntry) from a TLV-encoded wire format, validating required fields (Cost, OtherCost) and handling critical/optional components based on the provided context and ignoreCritical flag.
func (context *AdvEntryParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*AdvEntry, error) {

	var handled_Destination bool = false
	var handled_NextHop bool = false
	var handled_Cost bool = false
	var handled_OtherCost bool = false

	progress := -1
	_ = progress

	value := &AdvEntry{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 204:
				if true {
					handled = true
					handled_Destination = true
					value.Destination, err = context.Destination_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 206:
				if true {
					handled = true
					handled_NextHop = true
					value.NextHop, err = context.NextHop_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 208:
				if true {
					handled = true
					handled_Cost = true
					value.Cost = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Cost = uint64(value.Cost<<8) | uint64(x)
						}
					}
				}
			case 210:
				if true {
					handled = true
					handled_OtherCost = true
					value.OtherCost = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.OtherCost = uint64(value.OtherCost<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Destination && err == nil {
		value.Destination = nil
	}
	if !handled_NextHop && err == nil {
		value.NextHop = nil
	}
	if !handled_Cost && err == nil {
		err = enc.ErrSkipRequired{Name: "Cost", TypeNum: 208}
	}
	if !handled_OtherCost && err == nil {
		err = enc.ErrSkipRequired{Name: "OtherCost", TypeNum: 210}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the AdvEntry into a wire-format representation using AdvEntryEncoder for transmission or storage.
func (value *AdvEntry) Encode() enc.Wire {
	encoder := AdvEntryEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded AdvEntry as a single byte slice by joining its encoded components.
func (value *AdvEntry) Bytes() []byte {
	return value.Encode().Join()
}

// Parses an AdvEntry from encoded wire data using the provided parsing context, with an option to ignore critical parsing errors.
func ParseAdvEntry(reader enc.WireView, ignoreCritical bool) (*AdvEntry, error) {
	context := AdvEntryParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type DestinationEncoder struct {
	Length uint

	Name_length uint
}

type DestinationParsingContext struct {
}

// Initializes the encoder with the given Destination, computing the total encoded length of the name field including TLV encoding overhead for length and type fields.
func (encoder *DestinationEncoder) Init(value *Destination) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	encoder.Length = l

}

// Initializes the destination parsing context, preparing it for subsequent operations related to destination information parsing.
func (context *DestinationParsingContext) Init() {

}

// Encodes the Name component of a Destination structure into a binary buffer using TLV encoding, where type 7 signifies the Name field, followed by length and value sub-elements.
func (encoder *DestinationEncoder) EncodeInto(value *Destination, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

// Encodes a Destination object into a wire-format byte slice using the encoder's predefined length.
func (encoder *DestinationEncoder) Encode(value *Destination) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded Destination structure, extracting the Name field (type 7) and handling unrecognized critical fields according to the ignoreCritical flag.
func (context *DestinationParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Destination, error) {

	var handled_Name bool = false

	progress := -1
	_ = progress

	value := &Destination{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the Destination object into a wire format representation using the DestinationEncoder.
func (value *Destination) Encode() enc.Wire {
	encoder := DestinationEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// **Function Description:**  
Returns the byte slice representation of the encoded `Destination` value by joining its encoded components.
func (value *Destination) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a Destination object from wire-encoded data, optionally ignoring critical TLV elements not recognized by the parser.
func ParseDestination(reader enc.WireView, ignoreCritical bool) (*Destination, error) {
	context := DestinationParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type PrefixOpListEncoder struct {
	Length uint

	ExitRouter_encoder DestinationEncoder

	PrefixOpAdds_subencoder []struct {
		PrefixOpAdds_encoder PrefixOpAddEncoder
	}
	PrefixOpRemoves_subencoder []struct {
		PrefixOpRemoves_encoder PrefixOpRemoveEncoder
	}
}

type PrefixOpListParsingContext struct {
	ExitRouter_context DestinationParsingContext

	PrefixOpAdds_context    PrefixOpAddParsingContext
	PrefixOpRemoves_context PrefixOpRemoveParsingContext
}

// Initializes a `PrefixOpListEncoder` by setting up sub-encoders for `ExitRouter`, `PrefixOpAdds`, and `PrefixOpRemoves` fields and calculating the total encoded length of the `PrefixOpList` structure.
func (encoder *PrefixOpListEncoder) Init(value *PrefixOpList) {
	if value.ExitRouter != nil {
		encoder.ExitRouter_encoder.Init(value.ExitRouter)
	}

	{
		PrefixOpAdds_l := len(value.PrefixOpAdds)
		encoder.PrefixOpAdds_subencoder = make([]struct {
			PrefixOpAdds_encoder PrefixOpAddEncoder
		}, PrefixOpAdds_l)
		for i := 0; i < PrefixOpAdds_l; i++ {
			pseudoEncoder := &encoder.PrefixOpAdds_subencoder[i]
			pseudoValue := struct {
				PrefixOpAdds *PrefixOpAdd
			}{
				PrefixOpAdds: value.PrefixOpAdds[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixOpAdds != nil {
					encoder.PrefixOpAdds_encoder.Init(value.PrefixOpAdds)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		PrefixOpRemoves_l := len(value.PrefixOpRemoves)
		encoder.PrefixOpRemoves_subencoder = make([]struct {
			PrefixOpRemoves_encoder PrefixOpRemoveEncoder
		}, PrefixOpRemoves_l)
		for i := 0; i < PrefixOpRemoves_l; i++ {
			pseudoEncoder := &encoder.PrefixOpRemoves_subencoder[i]
			pseudoValue := struct {
				PrefixOpRemoves *PrefixOpRemove
			}{
				PrefixOpRemoves: value.PrefixOpRemoves[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixOpRemoves != nil {
					encoder.PrefixOpRemoves_encoder.Init(value.PrefixOpRemoves)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.ExitRouter != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ExitRouter_encoder.Length).EncodingLength())
		l += encoder.ExitRouter_encoder.Length
	}
	if value.PrefixOpReset {
		l += 3
		l += 1
	}
	if value.PrefixOpAdds != nil {
		for seq_i, seq_v := range value.PrefixOpAdds {
			pseudoEncoder := &encoder.PrefixOpAdds_subencoder[seq_i]
			pseudoValue := struct {
				PrefixOpAdds *PrefixOpAdd
			}{
				PrefixOpAdds: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixOpAdds != nil {
					l += 3
					l += uint(enc.TLNum(encoder.PrefixOpAdds_encoder.Length).EncodingLength())
					l += encoder.PrefixOpAdds_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PrefixOpRemoves != nil {
		for seq_i, seq_v := range value.PrefixOpRemoves {
			pseudoEncoder := &encoder.PrefixOpRemoves_subencoder[seq_i]
			pseudoValue := struct {
				PrefixOpRemoves *PrefixOpRemove
			}{
				PrefixOpRemoves: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixOpRemoves != nil {
					l += 3
					l += uint(enc.TLNum(encoder.PrefixOpRemoves_encoder.Length).EncodingLength())
					l += encoder.PrefixOpRemoves_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

// Initializes all sub-contexts (ExitRouter, PrefixOpAdds, and PrefixOpRemoves) within the PrefixOpListParsingContext to reset or prepare them for parsing operations.
func (context *PrefixOpListParsingContext) Init() {
	context.ExitRouter_context.Init()

	context.PrefixOpAdds_context.Init()
	context.PrefixOpRemoves_context.Init()
}

// Encodes a PrefixOpList structure (containing operations like exit router settings, prefix additions, and removals) into a TLV-encoded binary buffer for Named Data Networking.
func (encoder *PrefixOpListEncoder) EncodeInto(value *PrefixOpList, buf []byte) {

	pos := uint(0)

	if value.ExitRouter != nil {
		buf[pos] = byte(204)
		pos += 1
		pos += uint(enc.TLNum(encoder.ExitRouter_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.ExitRouter_encoder.Length > 0 {
			encoder.ExitRouter_encoder.EncodeInto(value.ExitRouter, buf[pos:])
			pos += encoder.ExitRouter_encoder.Length
		}
	}
	if value.PrefixOpReset {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(302))
		pos += 3
		buf[pos] = byte(0)
		pos += 1
	}
	if value.PrefixOpAdds != nil {
		for seq_i, seq_v := range value.PrefixOpAdds {
			pseudoEncoder := &encoder.PrefixOpAdds_subencoder[seq_i]
			pseudoValue := struct {
				PrefixOpAdds *PrefixOpAdd
			}{
				PrefixOpAdds: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixOpAdds != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(304))
					pos += 3
					pos += uint(enc.TLNum(encoder.PrefixOpAdds_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.PrefixOpAdds_encoder.Length > 0 {
						encoder.PrefixOpAdds_encoder.EncodeInto(value.PrefixOpAdds, buf[pos:])
						pos += encoder.PrefixOpAdds_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PrefixOpRemoves != nil {
		for seq_i, seq_v := range value.PrefixOpRemoves {
			pseudoEncoder := &encoder.PrefixOpRemoves_subencoder[seq_i]
			pseudoValue := struct {
				PrefixOpRemoves *PrefixOpRemove
			}{
				PrefixOpRemoves: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixOpRemoves != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(306))
					pos += 3
					pos += uint(enc.TLNum(encoder.PrefixOpRemoves_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.PrefixOpRemoves_encoder.Length > 0 {
						encoder.PrefixOpRemoves_encoder.EncodeInto(value.PrefixOpRemoves, buf[pos:])
						pos += encoder.PrefixOpRemoves_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

// Encodes a PrefixOpList into a wire-formatted byte slice using the allocated buffer size specified by the encoder.
func (encoder *PrefixOpListEncoder) Encode(value *PrefixOpList) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary wire-encoded PrefixOpList, extracting exit router information, prefix operation reset flags, and lists of prefix add/remove operations according to NDN TLV encoding rules.
func (context *PrefixOpListParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*PrefixOpList, error) {

	var handled_ExitRouter bool = false
	var handled_PrefixOpReset bool = false
	var handled_PrefixOpAdds bool = false
	var handled_PrefixOpRemoves bool = false

	progress := -1
	_ = progress

	value := &PrefixOpList{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 204:
				if true {
					handled = true
					handled_ExitRouter = true
					value.ExitRouter, err = context.ExitRouter_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 302:
				if true {
					handled = true
					handled_PrefixOpReset = true
					value.PrefixOpReset = true
					err = reader.Skip(int(l))
				}
			case 304:
				if true {
					handled = true
					handled_PrefixOpAdds = true
					if value.PrefixOpAdds == nil {
						value.PrefixOpAdds = make([]*PrefixOpAdd, 0)
					}
					{
						pseudoValue := struct {
							PrefixOpAdds *PrefixOpAdd
						}{}
						{
							value := &pseudoValue
							value.PrefixOpAdds, err = context.PrefixOpAdds_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.PrefixOpAdds = append(value.PrefixOpAdds, pseudoValue.PrefixOpAdds)
					}
					progress--
				}
			case 306:
				if true {
					handled = true
					handled_PrefixOpRemoves = true
					if value.PrefixOpRemoves == nil {
						value.PrefixOpRemoves = make([]*PrefixOpRemove, 0)
					}
					{
						pseudoValue := struct {
							PrefixOpRemoves *PrefixOpRemove
						}{}
						{
							value := &pseudoValue
							value.PrefixOpRemoves, err = context.PrefixOpRemoves_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.PrefixOpRemoves = append(value.PrefixOpRemoves, pseudoValue.PrefixOpRemoves)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ExitRouter && err == nil {
		value.ExitRouter = nil
	}
	if !handled_PrefixOpReset && err == nil {
		value.PrefixOpReset = false
	}
	if !handled_PrefixOpAdds && err == nil {
		// sequence - skip
	}
	if !handled_PrefixOpRemoves && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the PrefixOpList value into its wire representation using a PrefixOpListEncoder.
func (value *PrefixOpList) Encode() enc.Wire {
	encoder := PrefixOpListEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// **Description:**  
Encodes the PrefixOpList into a single byte slice by joining its encoded components.
func (value *PrefixOpList) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a PrefixOpList from wire-encoded data, with an option to ignore critical TLV elements during decoding.
func ParsePrefixOpList(reader enc.WireView, ignoreCritical bool) (*PrefixOpList, error) {
	context := PrefixOpListParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type PrefixOpAddEncoder struct {
	Length uint

	Name_length uint
}

type PrefixOpAddParsingContext struct {
}

// Initializes the PrefixOpAddEncoder's Length field by calculating the total encoded size of the provided PrefixOpAdd value, including TLV overhead for name components and cost.
func (encoder *PrefixOpAddEncoder) Init(value *PrefixOpAdd) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	l += 1
	l += uint(1 + enc.Nat(value.Cost).EncodingLength())
	encoder.Length = l

}

// Initializes the parsing context for processing a PrefixOpAdd operation.
func (context *PrefixOpAddParsingContext) Init() {

}

// Encodes a PrefixOpAdd control command into a TLV-encoded byte slice, including an optional Name component (type 7) and a Cost value (type 0xD0) representing the prefix addition parameters.
func (encoder *PrefixOpAddEncoder) EncodeInto(value *PrefixOpAdd, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	buf[pos] = byte(208)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Cost).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes a PrefixOpAdd value into a byte slice of length determined by the encoder and returns it as a wire structure.
func (encoder *PrefixOpAddEncoder) Encode(value *PrefixOpAdd) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded `PrefixOpAdd` object, reading a `Name` (type 7) and required `Cost` (type 208) fields, while handling unrecognized critical fields according to the `ignoreCritical` flag.
func (context *PrefixOpAddParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*PrefixOpAdd, error) {

	var handled_Name bool = false
	var handled_Cost bool = false

	progress := -1
	_ = progress

	value := &PrefixOpAdd{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			case 208:
				if true {
					handled = true
					handled_Cost = true
					value.Cost = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Cost = uint64(value.Cost<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_Cost && err == nil {
		err = enc.ErrSkipRequired{Name: "Cost", TypeNum: 208}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the PrefixOpAdd data structure into a wire format using the associated PrefixOpAddEncoder.
func (value *PrefixOpAdd) Encode() enc.Wire {
	encoder := PrefixOpAddEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded byte representation of the PrefixOpAdd value by joining its encoded components into a single byte slice.
func (value *PrefixOpAdd) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a wire-encoded PrefixOpAdd structure from the given reader, optionally ignoring critical unrecognized elements.
func ParsePrefixOpAdd(reader enc.WireView, ignoreCritical bool) (*PrefixOpAdd, error) {
	context := PrefixOpAddParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type PrefixOpRemoveEncoder struct {
	Length uint

	Name_length uint
}

type PrefixOpRemoveParsingContext struct {
}

// Initializes the encoder's length calculation based on the Name component of the PrefixOpRemove value, accounting for TLV encoding overhead and component lengths.
func (encoder *PrefixOpRemoveEncoder) Init(value *PrefixOpRemove) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Name_length).EncodingLength())
		l += encoder.Name_length
	}
	encoder.Length = l

}

// Initializes the parsing context for a prefix removal operation.
func (context *PrefixOpRemoveParsingContext) Init() {

}

// Encodes the Name field of a PrefixOpRemove structure into the provided byte buffer using NDN TLV encoding, starting with type 7 (NAME) and including each component's encoded value.
func (encoder *PrefixOpRemoveEncoder) EncodeInto(value *PrefixOpRemove, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.Name_length).EncodeInto(buf[pos:]))
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

// Encodes a PrefixOpRemove value into a TLV wire format by allocating a byte buffer of the encoder's specified length and populating it with the encoded data.
func (encoder *PrefixOpRemoveEncoder) Encode(value *PrefixOpRemove) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a binary-encoded PrefixOpRemove object from the provided WireView reader, extracting the optional Name field and handling critical/non-critical TLV elements according to the ignoreCritical flag.
func (context *PrefixOpRemoveParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*PrefixOpRemove, error) {

	var handled_Name bool = false

	progress := -1
	_ = progress

	value := &PrefixOpRemove{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					delegate := reader.Delegate(int(l))
					value.Name, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the PrefixOpRemove operation into a wire format for transmission or storage.
func (value *PrefixOpRemove) Encode() enc.Wire {
	encoder := PrefixOpRemoveEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the byte-encoded representation of the PrefixOpRemove operation, combining all encoded components into a single byte slice for transmission or storage.
func (value *PrefixOpRemove) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a PrefixOpRemove TLV structure from encoded data, using a parsing context and optionally ignoring critical elements.
func ParsePrefixOpRemove(reader enc.WireView, ignoreCritical bool) (*PrefixOpRemove, error) {
	context := PrefixOpRemoveParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StatusEncoder struct {
	Length uint

	NetworkName_encoder DestinationEncoder
	RouterName_encoder  DestinationEncoder
}

type StatusParsingContext struct {
	NetworkName_context DestinationParsingContext
	RouterName_context  DestinationParsingContext
}

// Initializes the StatusEncoder with the provided Status value, calculating the total encoded length by summing the TLV-encoded sizes of all fields, including optional sub-encoders and variable-length integers.
func (encoder *StatusEncoder) Init(value *Status) {

	if value.NetworkName != nil {
		encoder.NetworkName_encoder.Init(value.NetworkName)
	}
	if value.RouterName != nil {
		encoder.RouterName_encoder.Init(value.RouterName)
	}

	l := uint(0)
	l += 3
	l += uint(enc.TLNum(len(value.Version)).EncodingLength())
	l += uint(len(value.Version))
	if value.NetworkName != nil {
		l += 3
		l += uint(enc.TLNum(encoder.NetworkName_encoder.Length).EncodingLength())
		l += encoder.NetworkName_encoder.Length
	}
	if value.RouterName != nil {
		l += 3
		l += uint(enc.TLNum(encoder.RouterName_encoder.Length).EncodingLength())
		l += encoder.RouterName_encoder.Length
	}
	l += 3
	l += uint(1 + enc.Nat(value.NRibEntries).EncodingLength())
	l += 3
	l += uint(1 + enc.Nat(value.NNeighbors).EncodingLength())
	l += 3
	l += uint(1 + enc.Nat(value.NFibEntries).EncodingLength())
	encoder.Length = l

}

// Initializes the NetworkName and RouterName contexts within the StatusParsingContext by calling their respective Init methods.
func (context *StatusParsingContext) Init() {

	context.NetworkName_context.Init()
	context.RouterName_context.Init()

}

// Encodes a Status object into a binary buffer using TLV (Type-Length-Value) encoding, serializing fields such as HTTP status code, version, network/router names (if present), and count metrics like RIB entries, neighbors, and FIB entries.
func (encoder *StatusEncoder) EncodeInto(value *Status, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(401))
	pos += 3
	pos += uint(enc.TLNum(len(value.Version)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.Version)
	pos += uint(len(value.Version))
	if value.NetworkName != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(403))
		pos += 3
		pos += uint(enc.TLNum(encoder.NetworkName_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.NetworkName_encoder.Length > 0 {
			encoder.NetworkName_encoder.EncodeInto(value.NetworkName, buf[pos:])
			pos += encoder.NetworkName_encoder.Length
		}
	}
	if value.RouterName != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(405))
		pos += 3
		pos += uint(enc.TLNum(encoder.RouterName_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.RouterName_encoder.Length > 0 {
			encoder.RouterName_encoder.EncodeInto(value.RouterName, buf[pos:])
			pos += encoder.RouterName_encoder.Length
		}
	}
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(407))
	pos += 3

	buf[pos] = byte(enc.Nat(value.NRibEntries).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(409))
	pos += 3

	buf[pos] = byte(enc.Nat(value.NNeighbors).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(411))
	pos += 3

	buf[pos] = byte(enc.Nat(value.NFibEntries).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

// Encodes a Status object into a binary wire format using the encoder's specified length and returns it as a single slice within a Wire structure.
func (encoder *StatusEncoder) Encode(value *Status) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

// Parses a TLV-encoded Status object, extracting required fields like Version, NRibEntries, NNeighbors, and NFibEntries, and optional fields like NetworkName and RouterName, while handling critical and non-critical extensions based on the ignoreCritical flag.
func (context *StatusParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Status, error) {

	var handled_Version bool = false
	var handled_NetworkName bool = false
	var handled_RouterName bool = false
	var handled_NRibEntries bool = false
	var handled_NNeighbors bool = false
	var handled_NFibEntries bool = false

	progress := -1
	_ = progress

	value := &Status{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 401:
				if true {
					handled = true
					handled_Version = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.Version = builder.String()
						}
					}
				}
			case 403:
				if true {
					handled = true
					handled_NetworkName = true
					value.NetworkName, err = context.NetworkName_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 405:
				if true {
					handled = true
					handled_RouterName = true
					value.RouterName, err = context.RouterName_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 407:
				if true {
					handled = true
					handled_NRibEntries = true
					value.NRibEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NRibEntries = uint64(value.NRibEntries<<8) | uint64(x)
						}
					}
				}
			case 409:
				if true {
					handled = true
					handled_NNeighbors = true
					value.NNeighbors = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NNeighbors = uint64(value.NNeighbors<<8) | uint64(x)
						}
					}
				}
			case 411:
				if true {
					handled = true
					handled_NFibEntries = true
					value.NFibEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NFibEntries = uint64(value.NFibEntries<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Version && err == nil {
		err = enc.ErrSkipRequired{Name: "Version", TypeNum: 401}
	}
	if !handled_NetworkName && err == nil {
		value.NetworkName = nil
	}
	if !handled_RouterName && err == nil {
		value.RouterName = nil
	}
	if !handled_NRibEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NRibEntries", TypeNum: 407}
	}
	if !handled_NNeighbors && err == nil {
		err = enc.ErrSkipRequired{Name: "NNeighbors", TypeNum: 409}
	}
	if !handled_NFibEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NFibEntries", TypeNum: 411}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

// Encodes the Status object into a wire format representation using the associated StatusEncoder.
func (value *Status) Encode() enc.Wire {
	encoder := StatusEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

// Returns the encoded bytes of the Status by concatenating the results of its encoding.  

**Alternative (more concise):** Serializes the Status into a single byte slice by encoding and joining its components.
func (value *Status) Bytes() []byte {
	return value.Encode().Join()
}

// Parses a Status object from the provided encoded wire format data, with an option to ignore critical fields that cannot be processed.
func ParseStatus(reader enc.WireView, ignoreCritical bool) (*Status, error) {
	context := StatusParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
